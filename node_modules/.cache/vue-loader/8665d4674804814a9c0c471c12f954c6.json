{"remainingRequest":"/home/artur/programowanie/organiser/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/artur/programowanie/organiser/node_modules/vue2-timepicker/src/vue-timepicker.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/artur/programowanie/organiser/node_modules/vue2-timepicker/src/vue-timepicker.vue","mtime":1638016037242},{"path":"/home/artur/programowanie/organiser/node_modules/cache-loader/dist/cjs.js","mtime":1638016032464},{"path":"/home/artur/programowanie/organiser/node_modules/babel-loader/lib/index.js","mtime":1638016034515},{"path":"/home/artur/programowanie/organiser/node_modules/cache-loader/dist/cjs.js","mtime":1638016032464},{"path":"/home/artur/programowanie/organiser/node_modules/vue-loader/lib/index.js","mtime":1638016035031}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmNvbnN0IENPTkZJRyA9IHsKICBIT1VSX1RPS0VOUzogWydISCcsICdIJywgJ2hoJywgJ2gnLCAna2snLCAnayddLAogIE1JTlVURV9UT0tFTlM6IFsnbW0nLCAnbSddLAogIFNFQ09ORF9UT0tFTlM6IFsnc3MnLCAncyddLAogIEFQTV9UT0tFTlM6IFsnQScsICdhJ10sCiAgQkFTSUNfVFlQRVM6IFsnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ2FwbSddCn0KCmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHsKICBmb3JtYXQ6ICdISDptbScsCiAgbWludXRlSW50ZXJ2YWw6IDEsCiAgc2Vjb25kSW50ZXJ2YWw6IDEsCiAgaG91clJhbmdlOiBudWxsLAogIG1pbnV0ZVJhbmdlOiBudWxsLAogIHNlY29uZFJhbmdlOiBudWxsLAogIGhpZGVEaXNhYmxlZEhvdXJzOiBmYWxzZSwKICBoaWRlRGlzYWJsZWRNaW51dGVzOiBmYWxzZSwKICBoaWRlRGlzYWJsZWRTZWNvbmRzOiBmYWxzZSwKICBoaWRlRGlzYWJsZWRJdGVtczogZmFsc2UsCiAgaGlkZURyb3Bkb3duOiBmYWxzZSwKICBibHVyRGVsYXk6IDMwMCwKICBtYW51YWxJbnB1dFRpbWVvdXQ6IDEwMDAsCiAgZHJvcE9mZnNldEhlaWdodDogMTYwCn0KCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnVnVlVGltZXBpY2tlcicsCiAgcHJvcHM6IHsKICAgIHZhbHVlOiB7IHR5cGU6IFsgT2JqZWN0LCBTdHJpbmcgXSB9LAogICAgZm9ybWF0OiB7IHR5cGU6IFN0cmluZyB9LAogICAgbWludXRlSW50ZXJ2YWw6IHsgdHlwZTogWyBOdW1iZXIsIFN0cmluZyBdIH0sCiAgICBzZWNvbmRJbnRlcnZhbDogeyB0eXBlOiBbIE51bWJlciwgU3RyaW5nIF0gfSwKCiAgICBob3VyUmFuZ2U6IHsgdHlwZTogQXJyYXkgfSwKICAgIG1pbnV0ZVJhbmdlOiB7IHR5cGU6IEFycmF5IH0sCiAgICBzZWNvbmRSYW5nZTogeyB0eXBlOiBBcnJheSB9LAoKICAgIGhpZGVEaXNhYmxlZEhvdXJzOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICBoaWRlRGlzYWJsZWRNaW51dGVzOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICBoaWRlRGlzYWJsZWRTZWNvbmRzOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICBoaWRlRGlzYWJsZWRJdGVtczogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgIGhpZGVDbGVhckJ1dHRvbjogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAogICAgZGlzYWJsZWQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKICAgIGNsb3NlT25Db21wbGV0ZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgIGlkOiB7IHR5cGU6IFN0cmluZyB9LAogICAgbmFtZTogeyB0eXBlOiBTdHJpbmcgfSwKICAgIGlucHV0Q2xhc3M6IHsgdHlwZTogWyBTdHJpbmcsIE9iamVjdCwgQXJyYXkgXSB9LAogICAgcGxhY2Vob2xkZXI6IHsgdHlwZTogU3RyaW5nIH0sCiAgICB0YWJpbmRleDogeyB0eXBlOiBbIE51bWJlciwgU3RyaW5nIF0sIGRlZmF1bHQ6IDAgfSwKICAgIGlucHV0V2lkdGg6IHsgdHlwZTogU3RyaW5nIH0sCiAgICBhdXRvY29tcGxldGU6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnb2ZmJyB9LAoKICAgIGhvdXJMYWJlbDogeyB0eXBlOiBTdHJpbmcgfSwKICAgIG1pbnV0ZUxhYmVsOiB7IHR5cGU6IFN0cmluZyB9LAogICAgc2Vjb25kTGFiZWw6IHsgdHlwZTogU3RyaW5nIH0sCiAgICBhcG1MYWJlbDogeyB0eXBlOiBTdHJpbmcgfSwKICAgIGFtVGV4dDogeyB0eXBlOiBTdHJpbmcgfSwKICAgIHBtVGV4dDogeyB0eXBlOiBTdHJpbmcgfSwKCiAgICBibHVyRGVsYXk6IHsgdHlwZTogWyBOdW1iZXIsIFN0cmluZyBdIH0sCiAgICBhZHZhbmNlZEtleWJvYXJkOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCgogICAgbGF6eTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAogICAgYXV0b1Njcm9sbDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgIGRyb3BEaXJlY3Rpb246IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnZG93bicgfSwKICAgIGRyb3BPZmZzZXRIZWlnaHQ6IHsgdHlwZTogWyBOdW1iZXIsIFN0cmluZyBdIH0sCiAgICBjb250YWluZXJJZDogeyB0eXBlOiBTdHJpbmcgfSwKICAgIGFwcGVuZFRvQm9keTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgIG1hbnVhbElucHV0OiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICBtYW51YWxJbnB1dFRpbWVvdXQ6IHsgdHlwZTogWyBOdW1iZXIsIFN0cmluZyBdIH0sCiAgICBoaWRlRHJvcGRvd246IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKICAgIGZpeGVkRHJvcGRvd25CdXR0b246IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKCiAgICBkZWJ1Z01vZGU6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfQogIH0sCgogIGRhdGEgKCkgewogICAgcmV0dXJuIHsKICAgICAgdGltZVZhbHVlOiB7fSwKCiAgICAgIGhvdXJzOiBbXSwKICAgICAgbWludXRlczogW10sCiAgICAgIHNlY29uZHM6IFtdLAogICAgICBhcG1zOiBbXSwKCiAgICAgIGlzQWN0aXZlOiBmYWxzZSwKICAgICAgc2hvd0Ryb3Bkb3duOiBmYWxzZSwKICAgICAgaXNGb2N1c2luZzogZmFsc2UsCiAgICAgIGRlYm91bmNlVGltZXI6IHVuZGVmaW5lZCwKCiAgICAgIGhvdXJUeXBlOiAnSEgnLAogICAgICBtaW51dGVUeXBlOiAnbW0nLAogICAgICBzZWNvbmRUeXBlOiAnJywKICAgICAgYXBtVHlwZTogJycsCiAgICAgIGhvdXI6ICcnLAogICAgICBtaW51dGU6ICcnLAogICAgICBzZWNvbmQ6ICcnLAogICAgICBhcG06ICcnLAogICAgICBmdWxsVmFsdWVzOiB1bmRlZmluZWQsCiAgICAgIGJha0Rpc3BsYXlUaW1lOiB1bmRlZmluZWQsCiAgICAgIGRvQ2xlYXJBcG1DaGVja2luZzogZmFsc2UsCgogICAgICBzZWxlY3Rpb25UaW1lcjogdW5kZWZpbmVkLAogICAgICBrYklucHV0VGltZXI6IHVuZGVmaW5lZCwKICAgICAga2JJbnB1dExvZzogJycsCiAgICAgIGJha0N1cnJlbnRQb3M6IHVuZGVmaW5lZCwKICAgICAgZm9yY2VEcm9wT25Ub3A6IGZhbHNlCiAgICB9CiAgfSwKCiAgY29tcHV0ZWQ6IHsKICAgIG9wdHMgKCkgewogICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TKQoKICAgICAgaWYgKHRoaXMuZm9ybWF0ICYmIHRoaXMuZm9ybWF0Lmxlbmd0aCkgewogICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gU3RyaW5nKHRoaXMuZm9ybWF0KQogICAgICB9CgogICAgICBpZiAodGhpcy5pc051bWJlcih0aGlzLm1pbnV0ZUludGVydmFsKSkgewogICAgICAgIG9wdGlvbnMubWludXRlSW50ZXJ2YWwgPSArdGhpcy5taW51dGVJbnRlcnZhbAogICAgICB9CiAgICAgIC8vIG1pbnV0ZUludGVydmFsIGZhaWxzYWZlCiAgICAgIGlmICghb3B0aW9ucy5taW51dGVJbnRlcnZhbCB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsIDwgMSB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsID4gNjApIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIGlmIChvcHRpb25zLm1pbnV0ZUludGVydmFsID4gNjApIHsKICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgIm1pbnV0ZS1pbnRlcnZhbCIgc2hvdWxkIGJlIGxlc3MgdGhhbiA2MC4gQ3VycmVudCB2YWx1ZSBpcyAke3RoaXMubWludXRlSW50ZXJ2YWx9YCkKICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5taW51dGVJbnRlcnZhbCA9PT0gMCB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsIDwgMSkgewogICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGAibWludXRlLWludGVydmFsIiBzaG91bGQgYmUgTk8gbGVzcyB0aGFuIDEuIEN1cnJlbnQgdmFsdWUgaXMgJHt0aGlzLm1pbnV0ZUludGVydmFsfWApCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvcHRpb25zLm1pbnV0ZUludGVydmFsID09PSAwKSB7CiAgICAgICAgICBvcHRpb25zLm1pbnV0ZUludGVydmFsID0gNjAKICAgICAgICB9IGVsc2UgewogICAgICAgICAgb3B0aW9ucy5taW51dGVJbnRlcnZhbCA9IDEKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmlzTnVtYmVyKHRoaXMuc2Vjb25kSW50ZXJ2YWwpKSB7CiAgICAgICAgb3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA9ICt0aGlzLnNlY29uZEludGVydmFsCiAgICAgIH0KICAgICAgLy8gc2Vjb25kSW50ZXJ2YWwgZmFpbHNhZmUKICAgICAgaWYgKCFvcHRpb25zLnNlY29uZEludGVydmFsIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPCAxIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPiA2MCkgewogICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgaWYgKG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPiA2MCkgewogICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGAic2Vjb25kLWludGVydmFsIiBzaG91bGQgYmUgbGVzcyB0aGFuIDYwLiBDdXJyZW50IHZhbHVlIGlzICR7dGhpcy5zZWNvbmRJbnRlcnZhbH1gKQogICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNlY29uZEludGVydmFsID09PSAwIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPCAxKSB7CiAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYCJzZWNvbmQtaW50ZXJ2YWwiIHNob3VsZCBiZSBOTyBsZXNzIHRoYW4gMS4gQ3VycmVudCB2YWx1ZSBpcyAke3RoaXMuc2Vjb25kSW50ZXJ2YWx9YCkKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPT09IDApIHsKICAgICAgICAgIG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPSA2MAogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvcHRpb25zLnNlY29uZEludGVydmFsID0gMQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuaG91clJhbmdlICYmIEFycmF5LmlzQXJyYXkodGhpcy5ob3VyUmFuZ2UpKSB7CiAgICAgICAgb3B0aW9ucy5ob3VyUmFuZ2UgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuaG91clJhbmdlKSkKICAgICAgICBpZiAoIXRoaXMuaG91clJhbmdlLmxlbmd0aCAmJiB0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnVGhlICJob3VyLXJhbmdlIiBhcnJheSBpcyBlbXB0eSAobGVuZ3RoID09PSAwKScpCiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAodGhpcy5taW51dGVSYW5nZSAmJiBBcnJheS5pc0FycmF5KHRoaXMubWludXRlUmFuZ2UpKSB7CiAgICAgICAgb3B0aW9ucy5taW51dGVSYW5nZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5taW51dGVSYW5nZSkpCiAgICAgICAgaWYgKCF0aGlzLm1pbnV0ZVJhbmdlLmxlbmd0aCAmJiB0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnVGhlICJtaW51dGUtcmFuZ2UiIGFycmF5IGlzIGVtcHR5IChsZW5ndGggPT09IDApJykKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNlY29uZFJhbmdlICYmIEFycmF5LmlzQXJyYXkodGhpcy5zZWNvbmRSYW5nZSkpIHsKICAgICAgICBvcHRpb25zLnNlY29uZFJhbmdlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnNlY29uZFJhbmdlKSkKICAgICAgICBpZiAoIXRoaXMuc2Vjb25kUmFuZ2UubGVuZ3RoICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgInNlY29uZC1yYW5nZSIgYXJyYXkgaXMgZW1wdHkgKGxlbmd0aCA9PT0gMCknKQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICBvcHRpb25zLmhpZGVEaXNhYmxlZEl0ZW1zID0gdHJ1ZQogICAgICB9CgogICAgICBpZiAodGhpcy5oaWRlRGlzYWJsZWRIb3VycyB8fCB0aGlzLmhpZGVEaXNhYmxlZEl0ZW1zKSB7CiAgICAgICAgb3B0aW9ucy5oaWRlRGlzYWJsZWRIb3VycyA9IHRydWUKICAgICAgfQogICAgICBpZiAodGhpcy5oaWRlRGlzYWJsZWRNaW51dGVzIHx8IHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICBvcHRpb25zLmhpZGVEaXNhYmxlZE1pbnV0ZXMgPSB0cnVlCiAgICAgIH0KICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkU2Vjb25kcyB8fCB0aGlzLmhpZGVEaXNhYmxlZEl0ZW1zKSB7CiAgICAgICAgb3B0aW9ucy5oaWRlRGlzYWJsZWRTZWNvbmRzID0gdHJ1ZQogICAgICB9CgogICAgICBpZiAodGhpcy5oaWRlRHJvcGRvd24pIHsKICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgICAgb3B0aW9ucy5oaWRlRHJvcGRvd24gPSB0cnVlCiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnImhpZGUtZHJvcGRvd24iIG9ubHkgd29ya3Mgd2l0aCAibWFudWFsLWlucHV0IiBtb2RlJykKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmJsdXJEZWxheSAmJiArdGhpcy5ibHVyRGVsYXkgPiAwKSB7CiAgICAgICAgb3B0aW9ucy5ibHVyRGVsYXkgPSArdGhpcy5ibHVyRGVsYXkKICAgICAgfQoKICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXRUaW1lb3V0ICYmICt0aGlzLm1hbnVhbElucHV0VGltZW91dCA+IDApIHsKICAgICAgICBvcHRpb25zLm1hbnVhbElucHV0VGltZW91dCA9ICt0aGlzLm1hbnVhbElucHV0VGltZW91dAogICAgICB9CgogICAgICBpZiAodGhpcy5kcm9wT2Zmc2V0SGVpZ2h0ICYmICt0aGlzLmRyb3BPZmZzZXRIZWlnaHQgPiAwKSB7CiAgICAgICAgb3B0aW9ucy5kcm9wT2Zmc2V0SGVpZ2h0ID0gK3RoaXMuZHJvcE9mZnNldEhlaWdodAogICAgICB9CgogICAgICByZXR1cm4gb3B0aW9ucwogICAgfSwKCiAgICB1c2VTdHJpbmdWYWx1ZSAoKSB7CiAgICAgIHJldHVybiB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycKICAgIH0sCgogICAgZm9ybWF0U3RyaW5nICgpIHsKICAgICAgcmV0dXJuIHRoaXMub3B0cy5mb3JtYXQgfHwgREVGQVVMVF9PUFRJT05TLmZvcm1hdAogICAgfSwKCiAgICBpblVzZSAoKSB7CiAgICAgIGNvbnN0IHR5cGVzSW5Vc2UgPSBDT05GSUcuQkFTSUNfVFlQRVMuZmlsdGVyKHR5cGUgPT4gdGhpcy5nZXRUb2tlbkJ5VHlwZSh0eXBlKSkKICAgICAgLy8gU29ydCB0eXBlcyBhbmQgdG9rZW5zIGJ5IHRoZWlyIHNlcXVlbmNlIGluIHRoZSAiZm9ybWF0IiBzdHJpbmcKICAgICAgdHlwZXNJblVzZS5zb3J0KChsLCByKSA9PiB7CiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0U3RyaW5nLmluZGV4T2YodGhpcy5nZXRUb2tlbkJ5VHlwZShsKSB8fCBudWxsKSAtIHRoaXMuZm9ybWF0U3RyaW5nLmluZGV4T2YodGhpcy5nZXRUb2tlbkJ5VHlwZShyKSB8fCBudWxsKQogICAgICB9KQogICAgICBjb25zdCB0b2tlbnNJblVzZSA9IHR5cGVzSW5Vc2UubWFwKHR5cGUgPT4gdGhpcy5nZXRUb2tlbkJ5VHlwZSh0eXBlKSkKICAgICAgcmV0dXJuIHsKICAgICAgICBob3VyOiAhIXRoaXMuaG91clR5cGUsCiAgICAgICAgbWludXRlOiAhIXRoaXMubWludXRlVHlwZSwKICAgICAgICBzZWNvbmQ6ICEhdGhpcy5zZWNvbmRUeXBlLAogICAgICAgIGFwbTogISF0aGlzLmFwbVR5cGUsCiAgICAgICAgdHlwZXM6IHR5cGVzSW5Vc2UgfHwgW10sCiAgICAgICAgdG9rZW5zOiB0b2tlbnNJblVzZSB8fCBbXQogICAgICB9CiAgICB9LAoKICAgIGRpc3BsYXlUaW1lICgpIHsKICAgICAgbGV0IGZvcm1hdFN0cmluZyA9IFN0cmluZyh0aGlzLmZvcm1hdFN0cmluZykKICAgICAgaWYgKHRoaXMuaG91cikgewogICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5ob3VyVHlwZSwgJ2cnKSwgdGhpcy5ob3VyKQogICAgICB9CiAgICAgIGlmICh0aGlzLm1pbnV0ZSkgewogICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5taW51dGVUeXBlLCAnZycpLCB0aGlzLm1pbnV0ZSkKICAgICAgfQogICAgICBpZiAodGhpcy5zZWNvbmQgJiYgdGhpcy5zZWNvbmRUeXBlKSB7CiAgICAgICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLnNlY29uZFR5cGUsICdnJyksIHRoaXMuc2Vjb25kKQogICAgICB9CiAgICAgIGlmICh0aGlzLmFwbSAmJiB0aGlzLmFwbVR5cGUpIHsKICAgICAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMuYXBtVHlwZSwgJ2cnKSwgdGhpcy5hcG0pCiAgICAgIH0KICAgICAgcmV0dXJuIGZvcm1hdFN0cmluZwogICAgfSwKCiAgICBjdXN0b21EaXNwbGF5VGltZSAoKSB7CiAgICAgIGlmICghdGhpcy5hbVRleHQgJiYgIXRoaXMucG1UZXh0KSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVRpbWUKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5kaXNwbGF5VGltZS5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5hcG0sICdnJyksIHRoaXMuYXBtRGlzcGxheVRleHQodGhpcy5hcG0pKQogICAgfSwKCiAgICBpbnB1dElzRW1wdHkgKCkgewogICAgICByZXR1cm4gdGhpcy5mb3JtYXRTdHJpbmcgPT09IHRoaXMuZGlzcGxheVRpbWUKICAgIH0sCgogICAgYWxsVmFsdWVTZWxlY3RlZCAoKSB7CiAgICAgIGlmICgKICAgICAgICAodGhpcy5pblVzZS5ob3VyICYmICF0aGlzLmhvdXIpIHx8CiAgICAgICAgKHRoaXMuaW5Vc2UubWludXRlICYmICF0aGlzLm1pbnV0ZSkgfHwKICAgICAgICAodGhpcy5pblVzZS5zZWNvbmQgJiYgIXRoaXMuc2Vjb25kKSB8fAogICAgICAgICh0aGlzLmluVXNlLmFwbSAmJiAhdGhpcy5hcG0pCiAgICAgICkgewogICAgICAgIHJldHVybiBmYWxzZQogICAgICB9CiAgICAgIHJldHVybiB0cnVlCiAgICB9LAoKICAgIGNvbHVtbnNTZXF1ZW5jZSAoKSB7CiAgICAgIHJldHVybiB0aGlzLmluVXNlLnR5cGVzLm1hcCh0eXBlID0+IHR5cGUpIHx8IFtdCiAgICB9LAoKICAgIHNob3dDbGVhckJ0biAoKSB7CiAgICAgIGlmICh0aGlzLmhpZGVDbGVhckJ1dHRvbiB8fCB0aGlzLmRpc2FibGVkKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgcmV0dXJuICF0aGlzLmlucHV0SXNFbXB0eQogICAgfSwKCiAgICBzaG93RHJvcGRvd25CdG4gKCkgewogICAgICBpZiAodGhpcy5maXhlZERyb3Bkb3duQnV0dG9uKSB7IHJldHVybiB0cnVlIH0KICAgICAgaWYgKHRoaXMub3B0cy5oaWRlRHJvcGRvd24gJiYgdGhpcy5pc0FjdGl2ZSAmJiAhdGhpcy5zaG93RHJvcGRvd24pIHsKICAgICAgICByZXR1cm4gdHJ1ZQogICAgICB9CiAgICAgIHJldHVybiBmYWxzZQogICAgfSwKCiAgICBiYXNlT24xMkhvdXJzICgpIHsKICAgICAgcmV0dXJuIHRoaXMuaG91clR5cGUgPT09ICdoJyB8fCB0aGlzLmhvdXJUeXBlID09PSAnaGgnCiAgICB9LAoKICAgIGhvdXJSYW5nZUluMjRIckZvcm1hdCAoKSB7CiAgICAgIGlmICghdGhpcy5ob3VyVHlwZSB8fCAhdGhpcy5vcHRzLmhvdXJSYW5nZSkgeyByZXR1cm4gZmFsc2UgfQogICAgICBpZiAoIXRoaXMub3B0cy5ob3VyUmFuZ2UubGVuZ3RoKSB7IHJldHVybiBbXSB9CgogICAgICBjb25zdCByYW5nZSA9IFtdCiAgICAgIHRoaXMub3B0cy5ob3VyUmFuZ2UuZm9yRWFjaCh2YWx1ZSA9PiB7CiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHsKICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5lc3RlZCBhcnJheSB3aXRoaW4gImhvdXItcmFuZ2UiIG11c3QgY29udGFpbiBubyBtb3JlIHRoYW4gdHdvIGl0ZW1zLiBPbmx5IHRoZSBmaXJzdCB0d28gaXRlbXMgb2YgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50LmApCiAgICAgICAgICB9CgogICAgICAgICAgbGV0IHN0YXJ0ID0gdmFsdWVbMF0KICAgICAgICAgIGxldCBlbmQgPSB2YWx1ZVsxXSB8fCB2YWx1ZVswXQoKICAgICAgICAgIGlmICh0aGlzLmlzMTJoUmFuZ2Uoc3RhcnQpKSB7CiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy50cmFuc2xhdGUxMmhSYW5nZShzdGFydCkKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLmlzMTJoUmFuZ2UoZW5kKSkgewogICAgICAgICAgICBlbmQgPSB0aGlzLnRyYW5zbGF0ZTEyaFJhbmdlKGVuZCkKICAgICAgICAgIH0KCiAgICAgICAgICBmb3IgKGxldCBpID0gK3N0YXJ0OyBpIDw9ICtlbmQ7IGkrKykgewogICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+IDI0KSB7IGNvbnRpbnVlIH0KICAgICAgICAgICAgaWYgKCFyYW5nZS5pbmNsdWRlcyhpKSkgewogICAgICAgICAgICAgIHJhbmdlLnB1c2goaSkKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAodGhpcy5pczEyaFJhbmdlKHZhbHVlKSkgewogICAgICAgICAgICB2YWx1ZSA9IHRoaXMudHJhbnNsYXRlMTJoUmFuZ2UodmFsdWUpCiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZQogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDI0KSB7IHJldHVybiB9CiAgICAgICAgICBpZiAoIXJhbmdlLmluY2x1ZGVzKHZhbHVlKSkgewogICAgICAgICAgICByYW5nZS5wdXNoKHZhbHVlKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSkKICAgICAgcmFuZ2Uuc29ydCgobCwgcikgPT4geyByZXR1cm4gbCAtIHIgfSkKICAgICAgcmV0dXJuIHJhbmdlCiAgICB9LAoKICAgIHJlc3RyaWN0ZWRIb3VyUmFuZ2UgKCkgewogICAgICAvLyBObyByZXN0cmljdGlvbgogICAgICBpZiAoIXRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0KSB7IHJldHVybiBmYWxzZSB9CiAgICAgIC8vIDEyLUhvdXIKICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5ob3VyUmFuZ2VJbjI0SHJGb3JtYXQubWFwKCh2YWx1ZSkgPT4gewogICAgICAgICAgaWYgKHZhbHVlID09PSAxMikgewogICAgICAgICAgICByZXR1cm4gJzEycCcKICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDI0IHx8IHZhbHVlID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiAnMTJhJwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHZhbHVlID4gMTIgPyBgJHt2YWx1ZSAlIDEyfXBgIDogYCR7dmFsdWV9YWAKICAgICAgICB9KQogICAgICAgIHJldHVybiByYW5nZQogICAgICB9CiAgICAgIC8vIDI0LUhvdXIKICAgICAgcmV0dXJuIHRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0CiAgICB9LAoKICAgIHZhbGlkSG91cnNMaXN0ICgpIHsKICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7IHJldHVybiBmYWxzZSB9CiAgICAgIGlmICh0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UpIHsKICAgICAgICBsZXQgbGlzdCA9IFtdCiAgICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgbGlzdCA9IHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5tYXAoaHIgPT4gewogICAgICAgICAgICBjb25zdCBsID0gaHIuc3Vic3RyKDAsIGhyLmxlbmd0aCAtIDEpCiAgICAgICAgICAgIGNvbnN0IHIgPSBoci5zdWJzdHIoLTEpCiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmZvcm1hdFZhbHVlKHRoaXMuaG91clR5cGUsIGwpfSR7cn1gCiAgICAgICAgICB9KQogICAgICAgICAgY29uc3QgYW0xMkluZGV4ID0gbGlzdC5pbmRleE9mKCcxMmEnKQogICAgICAgICAgaWYgKGFtMTJJbmRleCA+IDApIHsKICAgICAgICAgICAgLy8gTWFrZSAnMTJhJyB0aGUgZmlyc3QgaXRlbSBpbiBoL2hoCiAgICAgICAgICAgIGxpc3QudW5zaGlmdChsaXN0LnNwbGljZShhbTEySW5kZXgsIDEpWzBdKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGxpc3QKICAgICAgICB9CiAgICAgICAgbGlzdCA9IHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5tYXAoaHIgPT4gewogICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VmFsdWUodGhpcy5ob3VyVHlwZSwgaHIpCiAgICAgICAgfSkKICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAxICYmIGxpc3RbMF0gJiYgbGlzdFswXSA9PT0gJzI0JykgewogICAgICAgICAgLy8gTWFrZSAnMjQnIHRoZSBsYXN0IGl0ZW0gaW4gay9rawogICAgICAgICAgbGlzdC5wdXNoKGxpc3Quc2hpZnQoKSkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxpc3QKICAgICAgfQogICAgICBpZiAodGhpcy5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChbXSwgdGhpcy5ob3Vycy5tYXAoaHIgPT4gYCR7aHJ9YWApLCB0aGlzLmhvdXJzLm1hcChociA9PiBgJHtocn1wYCkpCiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuaG91cnMKICAgIH0sCgogICAgaGFzICgpIHsKICAgICAgY29uc3QgcmVzdWx0ID0gewogICAgICAgIGN1c3RvbUFwbVRleHQ6IGZhbHNlCiAgICAgIH0KICAgICAgY29uc3QgYXBtRW5hYmxlZCA9ICEhdGhpcy5hcG1UeXBlCgogICAgICBpZiAoYXBtRW5hYmxlZCAmJiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdCAmJiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdC5sZW5ndGgpIHsKICAgICAgICBjb25zdCByYW5nZSA9IFtdLmNvbmNhdChbXSwgdGhpcy5ob3VyUmFuZ2VJbjI0SHJGb3JtYXQpCiAgICAgICAgcmVzdWx0LmFtID0gcmFuZ2Uuc29tZSh2YWx1ZSA9PiB2YWx1ZSA8IDEyIHx8IHZhbHVlID09PSAyNCkKICAgICAgICByZXN1bHQucG0gPSByYW5nZS5zb21lKHZhbHVlID0+IHZhbHVlID49IDEyICYmIHZhbHVlIDwgMjQpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0LmFtID0gYXBtRW5hYmxlZAogICAgICAgIHJlc3VsdC5wbSA9IGFwbUVuYWJsZWQKICAgICAgfQogICAgICBpZiAoKHRoaXMuYW1UZXh0ICYmIHRoaXMuYW1UZXh0Lmxlbmd0aCkgfHwgKHRoaXMucG1UZXh0ICYmIHRoaXMucG1UZXh0Lmxlbmd0aCkpIHsKICAgICAgICByZXN1bHQuY3VzdG9tQXBtVGV4dCA9IHRydWUKICAgICAgfQogICAgICByZXR1cm4gcmVzdWx0CiAgICB9LAoKICAgIG1pbnV0ZVJhbmdlTGlzdCAoKSB7CiAgICAgIGlmICghdGhpcy5taW51dGVUeXBlIHx8ICF0aGlzLm9wdHMubWludXRlUmFuZ2UpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgaWYgKCF0aGlzLm9wdHMubWludXRlUmFuZ2UubGVuZ3RoKSB7IHJldHVybiBbXSB9CiAgICAgIHJldHVybiB0aGlzLnJlbmRlclJhbmdlTGlzdCh0aGlzLm9wdHMubWludXRlUmFuZ2UsICdtaW51dGUnKQogICAgfSwKCiAgICBzZWNvbmRSYW5nZUxpc3QgKCkgewogICAgICBpZiAoIXRoaXMuc2Vjb25kVHlwZSB8fCAhdGhpcy5vcHRzLnNlY29uZFJhbmdlKSB7IHJldHVybiBmYWxzZSB9CiAgICAgIGlmICghdGhpcy5vcHRzLnNlY29uZFJhbmdlLmxlbmd0aCkgeyByZXR1cm4gW10gfQogICAgICByZXR1cm4gdGhpcy5yZW5kZXJSYW5nZUxpc3QodGhpcy5vcHRzLnNlY29uZFJhbmdlLCAnc2Vjb25kJykKICAgIH0sCiAgICAKICAgIGhvdXJMYWJlbFRleHQgKCkgewogICAgICByZXR1cm4gdGhpcy5ob3VyTGFiZWwgfHwgdGhpcy5ob3VyVHlwZQogICAgfSwKICAgIG1pbnV0ZUxhYmVsVGV4dCAoKSB7CiAgICAgIHJldHVybiB0aGlzLm1pbnV0ZUxhYmVsIHx8IHRoaXMubWludXRlVHlwZQogICAgfSwKICAgIHNlY29uZExhYmVsVGV4dCgpIHsKICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kTGFiZWwgfHwgdGhpcy5zZWNvbmRUeXBlCiAgICB9LAogICAgYXBtTGFiZWxUZXh0ICgpIHsKICAgICAgcmV0dXJuIHRoaXMuYXBtTGFiZWwgfHwgdGhpcy5hcG1UeXBlCiAgICB9LAoKICAgIGlucHV0V2lkdGhTdHlsZSAoKSB7CiAgICAgIGlmICghdGhpcy5pbnB1dFdpZHRoIHx8ICF0aGlzLmlucHV0V2lkdGgubGVuZ3RoKSB7IHJldHVybiB9CiAgICAgIHJldHVybiB7CiAgICAgICAgd2lkdGg6IHRoaXMuaW5wdXRXaWR0aAogICAgICB9CiAgICB9LAoKICAgIHRva2VuUmVnZXhCYXNlICgpIHsKICAgICAgcmV0dXJuIHRoaXMuaW5Vc2UudG9rZW5zLmpvaW4oJ3wnKQogICAgfSwKCiAgICB0b2tlbkNodW5rcyAoKSB7CiAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCAmJiAhdGhpcy51c2VTdHJpbmdWYWx1ZSkgeyByZXR1cm4gZmFsc2UgfQoKICAgICAgY29uc3QgZm9ybWF0U3RyaW5nID0gU3RyaW5nKHRoaXMuZm9ybWF0U3RyaW5nKQogICAgICBjb25zdCB0b2tlbnNSZWd4U3RyID0gYCgke3RoaXMudG9rZW5SZWdleEJhc2V9KSs/YAogICAgICBjb25zdCB0b2tlbnNNYXRjaEFsbCA9IHRoaXMuZ2V0TWF0Y2hBbGxCeVJlZ2V4KGZvcm1hdFN0cmluZywgdG9rZW5zUmVneFN0cikKCiAgICAgIGNvbnN0IHRva2VuQ2h1bmtzID0gW10KICAgICAgZm9yIChsZXQgdGtNYXRjaCBvZiB0b2tlbnNNYXRjaEFsbCkgewogICAgICAgIGNvbnN0IHJhd1Rva2VuID0gdGtNYXRjaFswXQogICAgICAgIGNvbnN0IHRva2VuTWF0Y2hJdGVtID0gewogICAgICAgICAgaW5kZXg6IHRrTWF0Y2guaW5kZXgsCiAgICAgICAgICB0b2tlbjogcmF3VG9rZW4sCiAgICAgICAgICB0eXBlOiB0aGlzLmdldFRva2VuVHlwZShyYXdUb2tlbiksCiAgICAgICAgICBuZWVkc0NhbGlicmF0ZTogcmF3VG9rZW4ubGVuZ3RoIDwgMiwKICAgICAgICAgIGxlbjogKHJhd1Rva2VuIHx8ICcnKS5sZW5ndGgKICAgICAgICB9CiAgICAgICAgdG9rZW5DaHVua3MucHVzaCh0b2tlbk1hdGNoSXRlbSkKICAgICAgfQogICAgICByZXR1cm4gdG9rZW5DaHVua3MKICAgIH0sCgogICAgbmVlZHNQb3NDYWxpYnJhdGUgKCkgewogICAgICBpZiAoIXRoaXMubWFudWFsSW5wdXQpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgcmV0dXJuIHRoaXMudG9rZW5DaHVua3Muc29tZShjaGsgPT4gY2hrLm5lZWRzQ2FsaWJyYXRlKQogICAgfSwKCiAgICB0b2tlbkNodW5rc1BvcyAoKSB7CiAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCkgeyByZXR1cm4gZmFsc2UgfQogICAgICBpZiAoIXRoaXMubmVlZHNQb3NDYWxpYnJhdGUpIHsKICAgICAgICByZXR1cm4gdGhpcy50b2tlbkNodW5rcy5tYXAoY2hrID0+IHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHRva2VuOiBjaGsudG9rZW4sCiAgICAgICAgICAgIHR5cGU6IGNoay50eXBlLAogICAgICAgICAgICBzdGFydDogY2hrLmluZGV4LAogICAgICAgICAgICBlbmQ6IGNoay5pbmRleCArIGNoay5sZW4KICAgICAgICAgIH0KICAgICAgICB9KQogICAgICB9CiAgICAgIGNvbnN0IGxpc3QgPSBbXQogICAgICBsZXQgY2FsaWJyYXRlTGVuID0gMAogICAgICB0aGlzLnRva2VuQ2h1bmtzLmZvckVhY2goY2hrID0+IHsKICAgICAgICBsZXQgY2h1bmtDdXJyZW50TGVuCiAgICAgICAgLy8gQWRqdXN0IGZvciBjdXN0b21pemVkIEFNL1BNIHRleHQKICAgICAgICBpZiAoY2hrLnR5cGUgPT09ICdhcG0nICYmIHRoaXMuaGFzLmN1c3RvbUFwbVRleHQpIHsKICAgICAgICAgIGlmICh0aGlzLmFwbSAmJiB0aGlzLmFwbS5sZW5ndGgpIHsKICAgICAgICAgICAgY29uc3QgY3VzdG9tQXBtVGV4dCA9IHRoaXMuYXBtLnRvTG93ZXJDYXNlKCkgPT09ICdhbScgPyB0aGlzLmFtVGV4dCA6IHRoaXMucG1UZXh0CiAgICAgICAgICAgIGNodW5rQ3VycmVudExlbiA9IChjdXN0b21BcG1UZXh0ICYmIGN1c3RvbUFwbVRleHQubGVuZ3RoKSA/IGN1c3RvbUFwbVRleHQubGVuZ3RoIDogY2hrLmxlbgogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY2h1bmtDdXJyZW50TGVuID0gY2hrLmxlbgogICAgICAgICAgfQogICAgICAgIC8vIE90aGVycwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjaHVua0N1cnJlbnRMZW4gPSB0aGlzW2Noay50eXBlXSAmJiB0aGlzW2Noay50eXBlXS5sZW5ndGggPyB0aGlzW2Noay50eXBlXS5sZW5ndGggOiBjaGsubGVuCiAgICAgICAgfQogICAgICAgIGxpc3QucHVzaCh7CiAgICAgICAgICB0b2tlbjogY2hrLnRva2VuLAogICAgICAgICAgdHlwZTogY2hrLnR5cGUsCiAgICAgICAgICBzdGFydDogY2hrLmluZGV4ICsgY2FsaWJyYXRlTGVuLAogICAgICAgICAgZW5kOiBjaGsuaW5kZXggKyBjYWxpYnJhdGVMZW4gKyBjaHVua0N1cnJlbnRMZW4KICAgICAgICB9KQogICAgICAgIGlmIChjaGsubmVlZHNDYWxpYnJhdGUgJiYgY2h1bmtDdXJyZW50TGVuID4gY2hrLmxlbikgewogICAgICAgICAgY2FsaWJyYXRlTGVuICs9IChjaHVua0N1cnJlbnRMZW4gLSBjaGsubGVuKQogICAgICAgIH0KICAgICAgfSkKICAgICAgcmV0dXJuIGxpc3QKICAgIH0sCgogICAgaW52YWxpZFZhbHVlcyAoKSB7CiAgICAgIGlmICh0aGlzLmlucHV0SXNFbXB0eSkgeyByZXR1cm4gW10gfQogICAgICBpZiAoIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSAmJiAhdGhpcy5taW51dGVSYW5nZUxpc3QgJiYgIXRoaXMuc2Vjb25kUmFuZ2VMaXN0ICYmIHRoaXMub3B0cy5taW51dGVJbnRlcnZhbCA9PT0gMSAmJiB0aGlzLm9wdHMuc2Vjb25kSW50ZXJ2YWwgPT09IDEpIHsgcmV0dXJuIFtdIH0KCiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdCiAgICAgIGlmICh0aGlzLmluVXNlLmhvdXIgJiYgIXRoaXMuaXNFbXB0eVZhbHVlKHRoaXMuaG91clR5cGUsIHRoaXMuaG91cikgJiYgKCF0aGlzLmlzVmFsaWRWYWx1ZSh0aGlzLmhvdXJUeXBlLCB0aGlzLmhvdXIpIHx8IHRoaXMuaXNEaXNhYmxlZCgnaG91cicsIHRoaXMuaG91cikpKSB7CiAgICAgICAgcmVzdWx0LnB1c2goJ2hvdXInKQogICAgICB9CiAgICAgIGlmICh0aGlzLmluVXNlLm1pbnV0ZSAmJiAhdGhpcy5pc0VtcHR5VmFsdWUodGhpcy5taW51dGVUeXBlLCB0aGlzLm1pbnV0ZSkgJiYgKCF0aGlzLmlzVmFsaWRWYWx1ZSh0aGlzLm1pbnV0ZVR5cGUsIHRoaXMubWludXRlKSB8fCB0aGlzLmlzRGlzYWJsZWQoJ21pbnV0ZScsIHRoaXMubWludXRlKSB8fCB0aGlzLm5vdEluSW50ZXJ2YWwoJ21pbnV0ZScsIHRoaXMubWludXRlKSkpIHsKICAgICAgICByZXN1bHQucHVzaCgnbWludXRlJykKICAgICAgfQogICAgICBpZiAodGhpcy5pblVzZS5zZWNvbmQgJiYgIXRoaXMuaXNFbXB0eVZhbHVlKHRoaXMuc2Vjb25kVHlwZSwgdGhpcy5zZWNvbmQpICYmICghdGhpcy5pc1ZhbGlkVmFsdWUodGhpcy5zZWNvbmRUeXBlLCB0aGlzLnNlY29uZCkgfHwgdGhpcy5pc0Rpc2FibGVkKCdzZWNvbmQnLCB0aGlzLnNlY29uZCkgfHwgdGhpcy5ub3RJbkludGVydmFsKCdzZWNvbmQnLCB0aGlzLnNlY29uZCkpKSB7CiAgICAgICAgcmVzdWx0LnB1c2goJ3NlY29uZCcpCiAgICAgIH0KICAgICAgaWYgKHRoaXMuaW5Vc2UuYXBtICYmICF0aGlzLmlzRW1wdHlWYWx1ZSh0aGlzLmFwbVR5cGUsIHRoaXMuYXBtKSAmJiAoIXRoaXMuaXNWYWxpZFZhbHVlKHRoaXMuYXBtVHlwZSwgdGhpcy5hcG0pIHx8IHRoaXMuaXNEaXNhYmxlZCgnYXBtJywgdGhpcy5hcG0pKSkgewogICAgICAgIHJlc3VsdC5wdXNoKCdhcG0nKQogICAgICB9CiAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIHJlc3VsdAogICAgICB9CiAgICAgIHJldHVybiBbXQogICAgfSwKCiAgICBoYXNJbnZhbGlkSW5wdXQgKCkgewogICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmludmFsaWRWYWx1ZXMgJiYgdGhpcy5pbnZhbGlkVmFsdWVzLmxlbmd0aCkKICAgIH0sCgogICAgYXV0b0RpcmVjdGlvbkVuYWJsZWQgKCkgewogICAgICByZXR1cm4gdGhpcy5kcm9wRGlyZWN0aW9uID09PSAnYXV0bycKICAgIH0sCgogICAgZHJvcGRvd25EaXJDbGFzcyAoKSB7CiAgICAgIGlmICh0aGlzLmF1dG9EaXJlY3Rpb25FbmFibGVkKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZm9yY2VEcm9wT25Ub3AgPyAnZHJvcC11cCcgOiAnZHJvcC1kb3duJwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLmRyb3BEaXJlY3Rpb24gPT09ICd1cCcgPyAnZHJvcC11cCcgOiAnZHJvcC1kb3duJyAgICAgIAogICAgfQogIH0sCgogIHdhdGNoOiB7CiAgICAnb3B0cy5mb3JtYXQnIChuZXdWYWx1ZSkgewogICAgICB0aGlzLnJlbmRlckZvcm1hdChuZXdWYWx1ZSkKICAgIH0sCiAgICAnb3B0cy5taW51dGVJbnRlcnZhbCcgKG5ld0ludGV2YWwpIHsKICAgICAgdGhpcy5yZW5kZXJMaXN0KCdtaW51dGUnLCBuZXdJbnRldmFsKQogICAgfSwKICAgICdvcHRzLnNlY29uZEludGVydmFsJyAobmV3SW50ZXZhbCkgewogICAgICB0aGlzLnJlbmRlckxpc3QoJ3NlY29uZCcsIG5ld0ludGV2YWwpCiAgICB9LAogICAgdmFsdWU6IHsKICAgICAgZGVlcDogdHJ1ZSwKICAgICAgaGFuZGxlciAoKSB7CiAgICAgICAgdGhpcy5yZWFkVmFsdWVzKCkKICAgICAgfQogICAgfSwKICAgIGRpc3BsYXlUaW1lICgpIHsKICAgICAgdGhpcy5maWxsVmFsdWVzKCkKICAgIH0sCiAgICBkaXNhYmxlZCAodG9EaXNhYmxlZCkgewogICAgICBpZiAodG9EaXNhYmxlZCkgewogICAgICAgIC8vIEZvcmNlIGNsb3NlIGRyb3Bkb3duIGFuZCByZXNldCBzdGF0dXMgd2hlbiBkaXNhYmxlZAogICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7CiAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2UKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgICB0aGlzLnNob3dEcm9wZG93biA9IGZhbHNlCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgJ2ludmFsaWRWYWx1ZXMubGVuZ3RoJyAobmV3TGVuZ3RoLCBvbGRMZW5ndGgpIHsKICAgICAgaWYgKG5ld0xlbmd0aCAmJiBuZXdMZW5ndGggPj0gMSkgewogICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgdGhpcy5pbnZhbGlkVmFsdWVzKQogICAgICB9IGVsc2UgaWYgKG9sZExlbmd0aCAmJiBvbGRMZW5ndGggPj0gMSkgewogICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgW10pCiAgICAgIH0KICAgIH0KICB9LAoKICBtZXRob2RzOiB7CiAgICBmb3JtYXRWYWx1ZSAodG9rZW4sIGkpIHsKICAgICAgaWYgKCF0aGlzLmlzTnVtYmVyKGkpKSB7IHJldHVybiAnJyB9CiAgICAgIGkgPSAraQogICAgICBzd2l0Y2ggKHRva2VuKSB7CiAgICAgICAgY2FzZSAnSCc6CiAgICAgICAgY2FzZSAnaCc6CiAgICAgICAgY2FzZSAnayc6CiAgICAgICAgY2FzZSAnbSc6CiAgICAgICAgY2FzZSAncyc6CiAgICAgICAgICBpZiAoWydoJywgJ2snXS5pbmNsdWRlcyh0b2tlbikgJiYgaSA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gdG9rZW4gPT09ICdrJyA/ICcyNCcgOiAnMTInCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gU3RyaW5nKGkpCiAgICAgICAgY2FzZSAnSEgnOgogICAgICAgIGNhc2UgJ21tJzoKICAgICAgICBjYXNlICdzcyc6CiAgICAgICAgY2FzZSAnaGgnOgogICAgICAgIGNhc2UgJ2trJzoKICAgICAgICAgIGlmIChbJ2hoJywgJ2trJ10uaW5jbHVkZXModG9rZW4pICYmIGkgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIHRva2VuID09PSAna2snID8gJzI0JyA6ICcxMicKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBpIDwgMTAgPyBgMCR7aX1gIDogU3RyaW5nKGkpCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldHVybiAnJwogICAgICB9CiAgICB9LAoKICAgIGNoZWNrQWNjZXB0aW5nVHlwZSAodmFsaWRWYWx1ZXMsIGZvcm1hdFN0cmluZykgewogICAgICBpZiAoIXZhbGlkVmFsdWVzIHx8ICFmb3JtYXRTdHJpbmcgfHwgIWZvcm1hdFN0cmluZy5sZW5ndGgpIHsgcmV0dXJuICcnIH0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZFZhbHVlcy5sZW5ndGg7IGkrKykgewogICAgICAgIGlmIChmb3JtYXRTdHJpbmcuaW5kZXhPZih2YWxpZFZhbHVlc1tpXSkgPiAtMSkgewogICAgICAgICAgcmV0dXJuIHZhbGlkVmFsdWVzW2ldCiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiAnJwogICAgfSwKCiAgICByZW5kZXJGb3JtYXQgKG5ld0Zvcm1hdCkgewogICAgICBuZXdGb3JtYXQgPSBuZXdGb3JtYXQgfHwgdGhpcy5vcHRzLmZvcm1hdCB8fCBERUZBVUxUX09QVElPTlMuZm9ybWF0CgogICAgICBsZXQgaG91clR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuSE9VUl9UT0tFTlMsIG5ld0Zvcm1hdCkKICAgICAgbGV0IG1pbnV0ZVR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuTUlOVVRFX1RPS0VOUywgbmV3Rm9ybWF0KQogICAgICB0aGlzLnNlY29uZFR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuU0VDT05EX1RPS0VOUywgbmV3Rm9ybWF0KQogICAgICB0aGlzLmFwbVR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuQVBNX1RPS0VOUywgbmV3Rm9ybWF0KQoKICAgICAgLy8gRmFpbHNhZmUgY2hlY2tpbmcKICAgICAgaWYgKCFob3VyVHlwZSAmJiAhbWludXRlVHlwZSAmJiAhdGhpcy5zZWNvbmRUeXBlICYmICF0aGlzLmFwbVR5cGUpIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUgJiYgdGhpcy5mb3JtYXQpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5vIHZhbGlkIHRva2VucyBmb3VuZCBpbiB5b3VyIGRlZmluZWQgImZvcm1hdCIgc3RyaW5nICIke3RoaXMuZm9ybWF0fSIuIEZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0ICJISDptbSIgZm9ybWF0LmApCiAgICAgICAgfQogICAgICAgIGhvdXJUeXBlID0gJ0hIJwogICAgICAgIG1pbnV0ZVR5cGUgPSAnbW0nCiAgICAgIH0KICAgICAgdGhpcy5ob3VyVHlwZSA9IGhvdXJUeXBlCiAgICAgIHRoaXMubWludXRlVHlwZSA9IG1pbnV0ZVR5cGUKCiAgICAgIHRoaXMuaG91clR5cGUgPyB0aGlzLnJlbmRlckhvdXJzTGlzdCgpIDogdGhpcy5ob3VycyA9IFtdCiAgICAgIHRoaXMubWludXRlVHlwZSA/IHRoaXMucmVuZGVyTGlzdCgnbWludXRlJykgOiB0aGlzLm1pbnV0ZXMgPSBbXQogICAgICB0aGlzLnNlY29uZFR5cGUgPyB0aGlzLnJlbmRlckxpc3QoJ3NlY29uZCcpIDogdGhpcy5zZWNvbmRzID0gW10KICAgICAgdGhpcy5hcG1UeXBlID8gdGhpcy5yZW5kZXJBcG1MaXN0KCkgOiB0aGlzLmFwbXMgPSBbXQoKICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgIHRoaXMucmVhZFZhbHVlcygpCiAgICAgIH0pCiAgICB9LAoKICAgIHJlbmRlckhvdXJzTGlzdCAoKSB7CiAgICAgIGNvbnN0IGhvdXJzQ291bnQgPSB0aGlzLmJhc2VPbjEySG91cnMgPyAxMiA6IDI0CiAgICAgIGNvbnN0IGhvdXJzID0gW10KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3Vyc0NvdW50OyBpKyspIHsKICAgICAgICBpZiAodGhpcy5ob3VyVHlwZSA9PT0gJ2snIHx8IHRoaXMuaG91clR5cGUgPT09ICdraycpIHsKICAgICAgICAgIGhvdXJzLnB1c2godGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmhvdXJUeXBlLCBpICsgMSkpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGhvdXJzLnB1c2godGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmhvdXJUeXBlLCBpKSkKICAgICAgICB9CiAgICAgIH0KICAgICAgdGhpcy5ob3VycyA9IGhvdXJzCiAgICB9LAoKICAgIHJlbmRlckxpc3QgKGxpc3RUeXBlLCBpbnRlcnZhbCkgewogICAgICBpZiAoIXRoaXMuaXNNaW51dGVPclNlY29uZChsaXN0VHlwZSkpIHsgcmV0dXJuIH0KCiAgICAgIGNvbnN0IGlzTWludXRlID0gbGlzdFR5cGUgPT09ICdtaW51dGUnCiAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgKGlzTWludXRlID8gKHRoaXMub3B0cy5taW51dGVJbnRlcnZhbCB8fCBERUZBVUxUX09QVElPTlMubWludXRlSW50ZXJ2YWwpIDogKHRoaXMub3B0cy5zZWNvbmRJbnRlcnZhbCB8fCBERUZBVUxUX09QVElPTlMuc2Vjb25kSW50ZXJ2YWwpKQoKICAgICAgY29uc3QgcmVzdWx0ID0gW10KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2MDsgaSArPSBpbnRlcnZhbCkgewogICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZm9ybWF0VmFsdWUoaXNNaW51dGUgPyB0aGlzLm1pbnV0ZVR5cGUgOiB0aGlzLnNlY29uZFR5cGUsIGkpKQogICAgICB9CiAgICAgIGlzTWludXRlID8gdGhpcy5taW51dGVzID0gcmVzdWx0IDogdGhpcy5zZWNvbmRzID0gcmVzdWx0CiAgICB9LAoKICAgIHJlbmRlckFwbUxpc3QgKCkgewogICAgICB0aGlzLmFwbXMgPSB0aGlzLmFwbVR5cGUgPT09ICdBJyA/IFsnQU0nLCAnUE0nXSA6IFsnYW0nLCAncG0nXQogICAgfSwKCiAgICByZWFkVmFsdWVzICgpIHsKICAgICAgaWYgKHRoaXMudXNlU3RyaW5nVmFsdWUpIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coYFJlY2VpdmVkIGEgc3RyaW5nIHZhbHVlOiAiJHt0aGlzLnZhbHVlfSJgKQogICAgICAgIH0KICAgICAgICB0aGlzLnJlYWRTdHJpbmdWYWx1ZXModGhpcy52YWx1ZSkKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coYFJlY2VpdmVkIGFuIG9iamVjdCB2YWx1ZTogIiR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSB8fCB7fSl9ImApCiAgICAgICAgfQogICAgICAgIHRoaXMucmVhZE9iamVjdFZhbHVlcyh0aGlzLnZhbHVlKQogICAgICB9CiAgICB9LAoKICAgIHJlYWRPYmplY3RWYWx1ZXMgKG9ialZhbHVlKSB7CiAgICAgIGNvbnN0IHRpbWVWYWx1ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqVmFsdWUgfHwge30pKQogICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aW1lVmFsdWUpCgogICAgICAvLyBGYWlsc2FmZSBmb3IgZW1wdHkgYHYtbW9kZWxgIG9iamVjdAogICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgewogICAgICAgIHRoaXMuYWRkRmFsbGJhY2tWYWx1ZXMoKQogICAgICAgIHJldHVybgogICAgICB9CgogICAgICBDT05GSUcuQkFTSUNfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHsKICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VG9rZW5CeVR5cGUodHlwZSkKICAgICAgICBpZiAodmFsdWVzLmluZGV4T2YodG9rZW4pID4gLTEpIHsKICAgICAgICAgIGNvbnN0IHNhbml0aXplZFZhbHVlID0gdGhpcy5zYW5pdGl6ZWRWYWx1ZSh0b2tlbiwgdGltZVZhbHVlW3Rva2VuXSkKICAgICAgICAgIHRoaXNbdHlwZV0gPSBzYW5pdGl6ZWRWYWx1ZQogICAgICAgICAgdGltZVZhbHVlW3Rva2VuXSA9IHNhbml0aXplZFZhbHVlCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXNbdHlwZV0gPSAnJwogICAgICAgIH0KICAgICAgfSkKICAgICAgdGhpcy50aW1lVmFsdWUgPSB0aW1lVmFsdWUKICAgIH0sCgogICAgZ2V0TWF0Y2hBbGxCeVJlZ2V4ICh0ZXN0U3RyaW5nLCByZWdleFN0cmluZykgewogICAgICBjb25zdCBzdHIgPSAncG9seWZpbGxUZXN0JwogICAgICBjb25zdCBuZWVkc1BvbHlmaWxsID0gQm9vbGVhbighc3RyLm1hdGNoQWxsIHx8IHR5cGVvZiBzdHIubWF0Y2hBbGwgIT09ICdmdW5jdGlvbicpCiAgICAgIHJldHVybiBuZWVkc1BvbHlmaWxsID8gdGhpcy5wb2x5ZmlsbE1hdGNoQWxsKHRlc3RTdHJpbmcsIHJlZ2V4U3RyaW5nKSA6IHRlc3RTdHJpbmcubWF0Y2hBbGwobmV3IFJlZ0V4cChyZWdleFN0cmluZywgJ2cnKSkKICAgIH0sCgogICAgcmVhZFN0cmluZ1ZhbHVlcyAoc3RyaW5nVmFsdWUpIHsKICAgICAgLy8gRmFpbHNhZmUgZm9yIGVtcHR5IGB2LW1vZGVsYCBzdHJpbmcKICAgICAgaWYgKCFzdHJpbmdWYWx1ZSB8fCAhc3RyaW5nVmFsdWUubGVuZ3RoKSB7CiAgICAgICAgdGhpcy5hZGRGYWxsYmFja1ZhbHVlcygpCiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIGNvbnN0IGZvcm1hdFN0cmluZyA9IFN0cmluZyh0aGlzLmZvcm1hdFN0cmluZykKICAgICAgY29uc3QgdG9rZW5zUmVneFN0ciA9IGAoJHt0aGlzLnRva2VuUmVnZXhCYXNlfSkrP2AKICAgICAgY29uc3Qgb3RoZXJzUmVneFN0ciA9IGBbXigke3RoaXMudG9rZW5SZWdleEJhc2V9KV0rYAoKICAgICAgY29uc3QgdG9rZW5zTWF0Y2hBbGwgPSB0aGlzLmdldE1hdGNoQWxsQnlSZWdleChmb3JtYXRTdHJpbmcsIHRva2Vuc1JlZ3hTdHIpCiAgICAgIGNvbnN0IG90aGVyc01hdGNoQWxsID0gdGhpcy5nZXRNYXRjaEFsbEJ5UmVnZXgoZm9ybWF0U3RyaW5nLCBvdGhlcnNSZWd4U3RyKQoKICAgICAgY29uc3QgY2h1bmtzID0gW10KICAgICAgY29uc3QgdG9rZW5DaHVua3MgPSBbXQoKICAgICAgZm9yIChsZXQgdGtNYXRjaCBvZiB0b2tlbnNNYXRjaEFsbCkgewogICAgICAgIGNvbnN0IHRva2VuTWF0Y2hJdGVtID0gewogICAgICAgICAgaW5kZXg6IHRrTWF0Y2guaW5kZXgsCiAgICAgICAgICB0b2tlbjogdGtNYXRjaFswXSwKICAgICAgICAgIGlzVmFsdWVUb2tlbjogdHJ1ZQogICAgICAgIH0KICAgICAgICBjaHVua3MucHVzaCh0b2tlbk1hdGNoSXRlbSkKICAgICAgICB0b2tlbkNodW5rcy5wdXNoKHRva2VuTWF0Y2hJdGVtKQogICAgICB9CgogICAgICBmb3IgKGxldCBvdE1hdGNoIG9mIG90aGVyc01hdGNoQWxsKSB7CiAgICAgICAgY2h1bmtzLnB1c2goewogICAgICAgICAgaW5kZXg6IG90TWF0Y2guaW5kZXgsCiAgICAgICAgICB0b2tlbjogb3RNYXRjaFswXQogICAgICAgIH0pCiAgICAgIH0KCiAgICAgIGNodW5rcy5zb3J0KChsLCByKSA9PiBsLmluZGV4IDwgci5pbmRleCA/IC0xIDogMSkKCiAgICAgIGxldCByZWdleENvbWJvID0gJycKICAgICAgY2h1bmtzLmZvckVhY2goY2h1bmsgPT4gewogICAgICAgIGlmIChjaHVuay5pc1ZhbHVlVG9rZW4pIHsKICAgICAgICAgIGNvbnN0IHRva2VuUmVnZXggPSB0aGlzLmdldFRva2VuUmVnZXgoY2h1bmsudG9rZW4pIHx8ICcnCiAgICAgICAgICByZWdleENvbWJvICs9IHRva2VuUmVnZXgKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3Qgc2FmZUNoYXJzID0gY2h1bmsudG9rZW4ucmVwbGFjZSgvXFx7MH0oXCp8XD98XC58XCspL2csICdcXCQxJykKICAgICAgICAgIHJlZ2V4Q29tYm8gKz0gYCg/OiR7c2FmZUNoYXJzfSlgCiAgICAgICAgfQogICAgICB9KQoKICAgICAgY29uc3QgY29tYm9SZWcgPSBuZXcgUmVnRXhwKHJlZ2V4Q29tYm8pCgogICAgICAvLyBEbyB0ZXN0IGJlZm9yZSBtYXRjaAogICAgICBpZiAoY29tYm9SZWcudGVzdChzdHJpbmdWYWx1ZSkpIHsKICAgICAgICBjb25zdCBtYXRjaFJlc3VsdHMgPSBzdHJpbmdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKHJlZ2V4Q29tYm8pKQogICAgICAgIGNvbnN0IHZhbHVlUmVzdWx0cyA9IG1hdGNoUmVzdWx0cy5zbGljZSgxLCB0b2tlbkNodW5rcy5sZW5ndGggKyAxKQogICAgICAgIGNvbnN0IHRpbWVWYWx1ZSA9IHt9CiAgICAgICAgdmFsdWVSZXN1bHRzLmZvckVhY2goKHZhbHVlLCB2ckluZGV4KSA9PiB7CiAgICAgICAgICBpZiAodG9rZW5DaHVua3NbdnJJbmRleF0pIHsKICAgICAgICAgICAgY29uc3QgdGFyZ2V0VG9rZW4gPSB0b2tlbkNodW5rc1t2ckluZGV4XS50b2tlbgogICAgICAgICAgICB0aW1lVmFsdWVbdGFyZ2V0VG9rZW5dID0gdGhpcy5zZXRWYWx1ZUZyb21TdHJpbmcodmFsdWUsIHRhcmdldFRva2VuKQogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgICAgdGhpcy50aW1lVmFsdWUgPSB0aW1lVmFsdWUKCiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICBjb25zdCB0b2tlbkNodW5rc0ZvckxvZyA9IHRva2VuQ2h1bmtzLm1hcCh0Q2h1bmsgPT4gdENodW5rICYmIHRDaHVuay50b2tlbikKICAgICAgICAgIHRoaXMuZGVidWdMb2coYFN1Y2Nlc3NmdWxseSBwYXJzZWQgdmFsdWVzICR7SlNPTi5zdHJpbmdpZnkodmFsdWVSZXN1bHRzKX1cbmZvciAke0pTT04uc3RyaW5naWZ5KHRva2VuQ2h1bmtzRm9yTG9nKX1cbmluIGZvcm1hdCBwYXR0ZXJuICcke3RoaXMuZm9ybWF0U3RyaW5nfSdgKQogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coYFRoZSBpbnB1dCBzdHJpbmcgaW4gInYtbW9kZWwiIGRvZXMgTk9UIG1hdGNoIHRoZSAiZm9ybWF0IiBwYXR0ZXJuXG5mb3JtYXQ6ICR7dGhpcy5mb3JtYXRTdHJpbmd9XG52LW1vZGVsOiAke3N0cmluZ1ZhbHVlfWApCiAgICAgICAgfQogICAgICB9CiAgICB9LAoKICAgIHBvbHlmaWxsTWF0Y2hBbGwgKHRhcmdldFN0cmluZywgcmVneFN0cikgewogICAgICBjb25zdCBtYXRjaGVzTGlzdCA9IHRhcmdldFN0cmluZy5tYXRjaChuZXcgUmVnRXhwKHJlZ3hTdHIsICdnJykpCiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdCiAgICAgIGNvbnN0IGluZGljZXNSZWcgPSBbXQogICAgICBpZiAobWF0Y2hlc0xpc3QgJiYgbWF0Y2hlc0xpc3QubGVuZ3RoKSB7CiAgICAgICAgbWF0Y2hlc0xpc3QuZm9yRWFjaChtYXRjaGVkSXRlbSA9PiB7CiAgICAgICAgICBjb25zdCBleGlzdEluZGV4ID0gaW5kaWNlc1JlZy5maW5kSW5kZXgoaWR4SXRlbSA9PiBpZHhJdGVtLnN0ciA9PT0gbWF0Y2hlZEl0ZW0pCiAgICAgICAgICBsZXQgaW5kZXgKICAgICAgICAgIGlmIChleGlzdEluZGV4ID49IDApIHsKICAgICAgICAgICAgaWYgKGluZGljZXNSZWdbZXhpc3RJbmRleF0gJiYgaW5kaWNlc1JlZ1tleGlzdEluZGV4XS5yZWdleCkgewogICAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc1JlZ1tleGlzdEluZGV4XS5yZWdleC5leGVjKHRhcmdldFN0cmluZykuaW5kZXgKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3QgaXRlbUluZGljZXNSZWdleCA9IG5ldyBSZWdFeHAobWF0Y2hlZEl0ZW0sICdnJykKICAgICAgICAgICAgaW5kZXggPSBpdGVtSW5kaWNlc1JlZ2V4LmV4ZWModGFyZ2V0U3RyaW5nKS5pbmRleAogICAgICAgICAgICBpbmRpY2VzUmVnLnB1c2goewogICAgICAgICAgICAgIHN0cjogU3RyaW5nKG1hdGNoZWRJdGVtKSwKICAgICAgICAgICAgICByZWdleDogaXRlbUluZGljZXNSZWdleAogICAgICAgICAgICB9KQogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0LnB1c2goewogICAgICAgICAgICAwOiBTdHJpbmcobWF0Y2hlZEl0ZW0pLAogICAgICAgICAgICBpbmRleDogaW5kZXgKICAgICAgICAgIH0pCiAgICAgICAgfSkKICAgICAgfQogICAgICByZXR1cm4gcmVzdWx0CiAgICB9LAoKICAgIGFkZEZhbGxiYWNrVmFsdWVzICgpIHsKICAgICAgY29uc3QgdGltZVZhbHVlID0ge30KICAgICAgdGhpcy5pblVzZS50eXBlcy5mb3JFYWNoKHR5cGUgPT4gewogICAgICAgIHRpbWVWYWx1ZVt0aGlzLmdldFRva2VuQnlUeXBlKHR5cGUpXSA9ICcnCiAgICAgIH0pCiAgICAgIHRoaXMudGltZVZhbHVlID0gdGltZVZhbHVlCiAgICB9LAoKICAgIHNldFZhbHVlRnJvbVN0cmluZyAocGFyc2VkVmFsdWUsIHRva2VuKSB7CiAgICAgIGlmICghdG9rZW4gfHwgIXBhcnNlZFZhbHVlKSB7IHJldHVybiAnJyB9CiAgICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuZ2V0VG9rZW5UeXBlKHRva2VuKQogICAgICBpZiAoIXRva2VuVHlwZSB8fCAhdG9rZW5UeXBlLmxlbmd0aCkgeyByZXR1cm4gJycgfQogICAgICBjb25zdCBzdGRWYWx1ZSA9IChwYXJzZWRWYWx1ZSAhPT0gdGhpcy5nZXRUb2tlbkJ5VHlwZSh0b2tlblR5cGUpKSA/IHBhcnNlZFZhbHVlIDogJycKICAgICAgdGhpc1t0b2tlblR5cGVdID0gc3RkVmFsdWUKICAgICAgcmV0dXJuIHN0ZFZhbHVlCiAgICB9LAoKICAgIGZpbGxWYWx1ZXMgKGZvcmNlRW1pdCkgewogICAgICBjb25zdCBmdWxsVmFsdWVzID0ge30KCiAgICAgIGNvbnN0IGJhc2VIb3VyID0gdGhpcy5ob3VyCiAgICAgIGNvbnN0IGJhc2VIb3VyVHlwZSA9IHRoaXMuaG91clR5cGUKCiAgICAgIGxldCBhcG1WYWx1ZQoKICAgICAgLy8gSG91ciB0eXBlIG9yIGhvdXIgdmFsdWUgaXMgTk9UIHNldCBpbiB0aGUgImZvcm1hdCIgc3RyaW5nCiAgICAgIGlmICghYmFzZUhvdXJUeXBlIHx8ICF0aGlzLmlzTnVtYmVyKGJhc2VIb3VyKSkgewogICAgICAgIENPTkZJRy5IT1VSX1RPS0VOUy5mb3JFYWNoKHRva2VuID0+IGZ1bGxWYWx1ZXNbdG9rZW5dID0gJycpCiAgICAgICAgYXBtVmFsdWUgPSB0aGlzLmxvd2VyQ2FzZWRBcG0odGhpcy5hcG0gfHwgJycpCiAgICAgICAgZnVsbFZhbHVlcy5hID0gYXBtVmFsdWUKICAgICAgICBmdWxsVmFsdWVzLkEgPSBhcG1WYWx1ZS50b1VwcGVyQ2FzZSgpCgogICAgICAvLyBCb3RoIEhvdXIgdHlwZSBhbmQgdmFsdWUgYXJlIHNldAogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGhvdXJWYWx1ZSA9ICtiYXNlSG91cgogICAgICAgIGNvbnN0IGFwbVZhbHVlID0gKHRoaXMuYmFzZU9uMTJIb3VycyAmJiB0aGlzLmFwbSkgPyB0aGlzLmxvd2VyQ2FzZWRBcG0odGhpcy5hcG0pIDogZmFsc2UKCiAgICAgICAgQ09ORklHLkhPVVJfVE9LRU5TLmZvckVhY2goKHRva2VuKSA9PiB7CiAgICAgICAgICBpZiAodG9rZW4gPT09IGJhc2VIb3VyVHlwZSkgewogICAgICAgICAgICBmdWxsVmFsdWVzW3Rva2VuXSA9IGJhc2VIb3VyCiAgICAgICAgICAgIHJldHVybgogICAgICAgICAgfQoKICAgICAgICAgIGxldCB2YWx1ZQogICAgICAgICAgbGV0IGFwbQogICAgICAgICAgc3dpdGNoICh0b2tlbikgewogICAgICAgICAgICBjYXNlICdIJzoKICAgICAgICAgICAgY2FzZSAnSEgnOgogICAgICAgICAgICBjYXNlICdrJzoKICAgICAgICAgICAgY2FzZSAna2snOgogICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgIGlmIChhcG1WYWx1ZSA9PT0gJ3BtJykgewogICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSA8IDEyID8gaG91clZhbHVlICsgMTIgOiBob3VyVmFsdWUKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoWydrJywgJ2trJ10uaW5jbHVkZXModG9rZW4pKSB7CiAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlID09PSAxMiA/IDI0IDogaG91clZhbHVlCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSAlIDEyCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmIChbJ2snLCAna2snXS5pbmNsdWRlcyh0b2tlbikpIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgPT09IDAgPyAyNCA6IGhvdXJWYWx1ZQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgJSAyNAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmdWxsVmFsdWVzW3Rva2VuXSA9IHRoaXMuZm9ybWF0VmFsdWUodG9rZW4sIHZhbHVlKQogICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGNhc2UgJ2gnOgogICAgICAgICAgICBjYXNlICdoaCc6CiAgICAgICAgICAgICAgLy8gaCA8LT4gaGgKICAgICAgICAgICAgICBpZiAodGhpcy5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZQogICAgICAgICAgICAgICAgYXBtID0gYXBtVmFsdWUgfHwgJycKICAgICAgICAgICAgICAvLyBSZWFkIGZyb20gb3RoZXIgaG91ciBmb3JtYXRzCiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmIChob3VyVmFsdWUgPiAxMSAmJiBob3VyVmFsdWUgPCAyNCkgewogICAgICAgICAgICAgICAgICBhcG0gPSAncG0nCiAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlID09PSAxMiA/IDEyIDogaG91clZhbHVlICUgMTIKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGFwbSA9ICdhbScKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgJSAxMiA9PT0gMCA/IDEyIDogaG91clZhbHVlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGZ1bGxWYWx1ZXNbdG9rZW5dID0gdGhpcy5mb3JtYXRWYWx1ZSh0b2tlbiwgdmFsdWUpCiAgICAgICAgICAgICAgZnVsbFZhbHVlcy5hID0gYXBtCiAgICAgICAgICAgICAgZnVsbFZhbHVlcy5BID0gYXBtLnRvVXBwZXJDYXNlKCkKICAgICAgICAgICAgICBicmVhawogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgIH0KCiAgICAgIGZ1bGxWYWx1ZXMubSA9IHRoaXMuZm9ybWF0VmFsdWUoJ20nLCB0aGlzLm1pbnV0ZSkKICAgICAgZnVsbFZhbHVlcy5tbSA9IHRoaXMuZm9ybWF0VmFsdWUoJ21tJywgdGhpcy5taW51dGUpCiAgICAgIGZ1bGxWYWx1ZXMucyA9IHRoaXMuZm9ybWF0VmFsdWUoJ3MnLCB0aGlzLnNlY29uZCkKICAgICAgZnVsbFZhbHVlcy5zcyA9IHRoaXMuZm9ybWF0VmFsdWUoJ3NzJywgdGhpcy5zZWNvbmQpCgogICAgICB0aGlzLmZ1bGxWYWx1ZXMgPSBmdWxsVmFsdWVzCgogICAgICAvLyBPbiBsYXp5IG1vZGUsIGVtaXQgYGlucHV0YCBhbmQgYGNoYW5nZWAgZXZlbnRzIG9ubHkgd2hlbjoKICAgICAgLy8gLSBUaGUgdXNlciBwaWNrIGEgbmV3IHZhbHVlIGFuZCB0aGVuIGNsb3NlIHRoZSBkcm9wZG93bgogICAgICAvLyAtIFRoZSB1c2VyIGNsaWNrIHRoZSAoIngiKSBjbGVhciBidXR0b24KICAgICAgaWYgKCF0aGlzLmxhenkgfHwgZm9yY2VFbWl0KSB7CiAgICAgICAgdGhpcy5lbWl0VGltZVZhbHVlKCkKICAgICAgfQoKICAgICAgaWYgKHRoaXMuY2xvc2VPbkNvbXBsZXRlICYmIHRoaXMuYWxsVmFsdWVTZWxlY3RlZCAmJiB0aGlzLnNob3dEcm9wZG93bikgewogICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlKCkKICAgICAgfQogICAgfSwKCiAgICBnZXRGdWxsRGF0YSAoKSB7CiAgICAgIGlmICghdGhpcy5mdWxsVmFsdWVzKSB7CiAgICAgICAgdGhpcy5maWxsVmFsdWVzKCkKICAgICAgfQogICAgICByZXR1cm4gewogICAgICAgIGRhdGE6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5mdWxsVmFsdWVzKSksCiAgICAgICAgZGlzcGxheVRpbWU6IHRoaXMuaW5wdXRJc0VtcHR5ID8gJycgOiBTdHJpbmcodGhpcy5kaXNwbGF5VGltZSkKICAgICAgfQogICAgfSwKCiAgICBlbWl0VGltZVZhbHVlICgpIHsKICAgICAgaWYgKHRoaXMubGF6eSAmJiB0aGlzLmJha0Rpc3BsYXlUaW1lID09PSB0aGlzLmRpc3BsYXlUaW1lKSB7CiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgdmFsdWUgZG9lcyBub3QgY2hhbmdlIG9uIGBsYXp5YCBtb2RlLiBTa2lwIHRoZSBlbWl0dGluZyBgaW5wdXRgIGFuZCBgY2hhbmdlYCBldmVudC4nKQogICAgICAgIH0KICAgICAgICByZXR1cm4KICAgICAgfQoKICAgICAgY29uc3QgZnVsbERhdGEgPSB0aGlzLmdldEZ1bGxEYXRhKCkKCiAgICAgIGlmICh0aGlzLnVzZVN0cmluZ1ZhbHVlKSB7CiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBmdWxsRGF0YS5kaXNwbGF5VGltZSkKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBmdWxsVmFsdWVzID0gZnVsbERhdGEuZGF0YQogICAgICAgIGNvbnN0IHRva2Vuc0luVXNlID0gdGhpcy5pblVzZS50b2tlbnMgfHwgW10KICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSB7fQogICAgICAgIHRva2Vuc0luVXNlLmZvckVhY2goKHRva2VuKSA9PiB7CiAgICAgICAgICB0aW1lVmFsdWVbdG9rZW5dID0gZnVsbFZhbHVlc1t0b2tlbl0gfHwgJycKICAgICAgICB9KQogICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aW1lVmFsdWUpKSkKICAgICAgfQoKICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZnVsbERhdGEpCiAgICB9LAoKICAgIHRyYW5zbGF0ZTEyaFJhbmdlICh2YWx1ZSkgewogICAgICBjb25zdCB2YWx1ZVQgPSB0aGlzLm1hdGNoMTJoUmFuZ2UodmFsdWUpCiAgICAgIGlmICgrdmFsdWVUWzFdID09PSAxMikgewogICAgICAgIHJldHVybiArdmFsdWVUWzFdICsgKHZhbHVlVFsyXS50b0xvd2VyQ2FzZSgpID09PSAncCcgPyAwIDogMTIpCiAgICAgIH0KICAgICAgcmV0dXJuICt2YWx1ZVRbMV0gKyAodmFsdWVUWzJdLnRvTG93ZXJDYXNlKCkgPT09ICdwJyA/IDEyIDogMCkKICAgIH0sCgogICAgaXNEaXNhYmxlZCAodHlwZSwgdmFsdWUpIHsKICAgICAgaWYgKCF0aGlzLmlzQmFzaWNUeXBlKHR5cGUpIHx8ICF0aGlzLmluVXNlW3R5cGVdKSB7IHJldHVybiB0cnVlIH0KICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgY2FzZSAnaG91cic6CiAgICAgICAgICByZXR1cm4gdGhpcy5pc0Rpc2FibGVkSG91cih2YWx1ZSkKICAgICAgICBjYXNlICdtaW51dGUnOgogICAgICAgIGNhc2UgJ3NlY29uZCc6CiAgICAgICAgICBpZiAoIXRoaXNbYCR7dHlwZX1SYW5nZUxpc3RgXSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAhdGhpc1tgJHt0eXBlfVJhbmdlTGlzdGBdLmluY2x1ZGVzKHZhbHVlKQogICAgICAgIGNhc2UgJ2FwbSc6CiAgICAgICAgICBpZiAoIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAhdGhpcy5oYXNbdGhpcy5sb3dlckNhc2VkQXBtKHZhbHVlKV0KICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgfQogICAgfSwKCiAgICBpc0Rpc2FibGVkSG91ciAodmFsdWUpIHsKICAgICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgIGlmICghdGhpcy5hcG0gfHwgIXRoaXMuYXBtLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5hcG0udG9Mb3dlckNhc2UoKSA9PT0gJ2FtJyA/ICdhJyA6ICdwJwogICAgICAgICAgcmV0dXJuICF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UuaW5jbHVkZXMoYCR7K3ZhbHVlfSR7dG9rZW59YCkKICAgICAgICB9CiAgICAgIH0KICAgICAgLy8gRmFsbGJhY2sgZm9yICdISCcgYW5kICdIIGhvdXIgZm9ybWF0IHdpdGggYSBgaG91ci1yYW5nZWAgaW4gYSAxMi1ob3VyIGZvcm0KICAgICAgaWYgKAogICAgICAgICh0aGlzLmhvdXJUeXBlID09PSAnSEgnIHx8IHRoaXMuaG91clR5cGUgPT09ICdIJykgJiYKICAgICAgICArdmFsdWUgPT09IDAgJiYgdGhpcy5yZXN0cmljdGVkSG91clJhbmdlLmluY2x1ZGVzKDI0KQogICAgICApIHsKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICByZXR1cm4gIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5pbmNsdWRlcygrdmFsdWUpCiAgICB9LAoKICAgIG5vdEluSW50ZXJ2YWwgKHNlY3Rpb24sIHZhbHVlKSB7CiAgICAgIGlmICghc2VjdGlvbiB8fCAhdGhpcy5pc01pbnV0ZU9yU2Vjb25kKHNlY3Rpb24pKSB7IHJldHVybiB9CiAgICAgIGlmICh0aGlzLm9wdHNbYCR7c2VjdGlvbn1JbnRlcnZhbGBdID09PSAxKSB7IHJldHVybiBmYWxzZSB9CiAgICAgIHJldHVybiArdmFsdWUgJSB0aGlzLm9wdHNbYCR7c2VjdGlvbn1JbnRlcnZhbGBdICE9PSAwCiAgICB9LAoKICAgIHJlbmRlclJhbmdlTGlzdCAocmF3UmFuZ2UsIHNlY3Rpb24pIHsKICAgICAgaWYgKCFyYXdSYW5nZSB8fCAhc2VjdGlvbiB8fCAhdGhpcy5pc01pbnV0ZU9yU2Vjb25kKHNlY3Rpb24pKSB7IHJldHVybiBbXSB9CiAgICAgIGNvbnN0IHJhbmdlID0gW10KICAgICAgbGV0IGZvcm1hdGVkVmFsdWUKICAgICAgcmF3UmFuZ2UuZm9yRWFjaCh2YWx1ZSA9PiB7CiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHsKICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5lc3RlZCBhcnJheSB3aXRoaW4gIiR7c2VjdGlvbn0tcmFuZ2UiIG11c3QgY29udGFpbiBubyBtb3JlIHRoYW4gdHdvIGl0ZW1zLiBPbmx5IHRoZSBmaXJzdCB0d28gaXRlbXMgb2YgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50LmApCiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBzdGFydCA9IHZhbHVlWzBdCiAgICAgICAgICBjb25zdCBlbmQgPSB2YWx1ZVsxXSB8fCB2YWx1ZVswXQogICAgICAgICAgZm9yIChsZXQgaSA9ICtzdGFydDsgaSA8PSArZW5kOyBpKyspIHsKICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPiA1OSkgeyBjb250aW51ZSB9CiAgICAgICAgICAgIGZvcm1hdGVkVmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKHRoaXMuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbiksIGkpCiAgICAgICAgICAgIGlmICghcmFuZ2UuaW5jbHVkZXMoZm9ybWF0ZWRWYWx1ZSkpIHsKICAgICAgICAgICAgICByYW5nZS5wdXNoKGZvcm1hdGVkVmFsdWUpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKCt2YWx1ZSA8IDAgfHwgK3ZhbHVlID4gNTkpIHsgcmV0dXJuIH0KICAgICAgICAgIGZvcm1hdGVkVmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKHRoaXMuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbiksIHZhbHVlKQogICAgICAgICAgaWYgKCFyYW5nZS5pbmNsdWRlcyhmb3JtYXRlZFZhbHVlKSkgewogICAgICAgICAgICByYW5nZS5wdXNoKGZvcm1hdGVkVmFsdWUpCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KQogICAgICByYW5nZS5zb3J0KChsLCByKSA9PiB7IHJldHVybiBsIC0gciB9KQogICAgICAvLyBEZWJ1ZyBNb2RlCiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgIGNvbnN0IGZ1bGxMaXN0ID0gKHNlY3Rpb24gPT09ICdtaW51dGUnID8gdGhpcy5taW51dGVzIDogdGhpcy5zZWNvbmRzKSB8fCBbXQogICAgICAgIGNvbnN0IHZhbGlkSXRlbXMgPSBmdWxsTGlzdC5maWx0ZXIoaXRlbSA9PiByYW5nZS5pbmNsdWRlcyhpdGVtKSkKICAgICAgICBpZiAoIXZhbGlkSXRlbXMgfHwgIXZhbGlkSXRlbXMubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoc2VjdGlvbiA9PT0gJ21pbnV0ZScpIHsKICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgVGhlIG1pbnV0ZSBsaXN0IGlzIGVtcHR5IGR1ZSB0byB0aGUgIm1pbnV0ZS1yYW5nZSIgY29uZmlnXG5taW51dGUtcmFuZ2U6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5taW51dGVSYW5nZSl9XG5taW51dGUtaW50ZXJ2YWw6ICR7dGhpcy5vcHRzLm1pbnV0ZUludGVydmFsfWApCiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBUaGUgc2Vjb25kIGxpc3QgaXMgZW1wdHkgZHVlIHRvIHRoZSAic2Vjb25kLXJhbmdlIiBjb25maWdcbnNlY29uZC1yYW5nZTogJHtKU09OLnN0cmluZ2lmeSh0aGlzLnNlY29uZFJhbmdlKX1cbnNlY29uZC1pbnRlcnZhbDogJHt0aGlzLm9wdHMuc2Vjb25kSW50ZXJ2YWx9YCkKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJhbmdlCiAgICB9LAoKICAgIGZvcmNlQXBtU2VsZWN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQpIHsKICAgICAgICAvLyBTa2lwIHRoaXMgdG8gYWxsb3cgdXNlcnMgdG8gcGFzdGUgYSBzdHJpbmcgdmFsdWUgZnJvbSB0aGUgY2xpcGJvYXJkIGluIE1hbnVhbCBJbnB1dCBtb2RlCiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgaWYgKHRoaXMuYXBtVHlwZSAmJiAhdGhpcy5hcG0pIHsKICAgICAgICBpZiAodGhpcy5oYXMuYW0gfHwgdGhpcy5oYXMucG0pIHsKICAgICAgICAgIHRoaXMuZG9DbGVhckFwbUNoZWNraW5nID0gdHJ1ZQogICAgICAgICAgY29uc3QgYXBtVmFsdWUgPSB0aGlzLmhhcy5hbSA/ICdhbScgOiAncG0nCiAgICAgICAgICB0aGlzLmFwbSA9IHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gYXBtVmFsdWUudG9VcHBlckNhc2UoKSA6IGFwbVZhbHVlCiAgICAgICAgfQogICAgICB9CiAgICB9LAoKICAgIGVtcHR5QXBtU2VsZWN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuZG9DbGVhckFwbUNoZWNraW5nICYmIHRoaXMuaG91ciA9PT0gJycgJiYgdGhpcy5taW51dGUgPT09ICcnICYmIHRoaXMuc2Vjb25kID09PSAnJykgewogICAgICAgIHRoaXMuYXBtID0gJycKICAgICAgfQogICAgICB0aGlzLmRvQ2xlYXJBcG1DaGVja2luZyA9IGZhbHNlCiAgICB9LAoKICAgIGFwbURpc3BsYXlUZXh0IChhcG1WYWx1ZSkgewogICAgICBpZiAodGhpcy5hbVRleHQgJiYgdGhpcy5sb3dlckNhc2VkQXBtKGFwbVZhbHVlKSA9PT0gJ2FtJykgewogICAgICAgIHJldHVybiB0aGlzLmFtVGV4dAogICAgICB9CiAgICAgIGlmICh0aGlzLnBtVGV4dCAmJiB0aGlzLmxvd2VyQ2FzZWRBcG0oYXBtVmFsdWUpID09PSAncG0nKSB7CiAgICAgICAgcmV0dXJuIHRoaXMucG1UZXh0CiAgICAgIH0KICAgICAgcmV0dXJuIGFwbVZhbHVlCiAgICB9LAoKICAgIHRvZ2dsZUFjdGl2ZSAoKSB7CiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybiB9CiAgICAgIHRoaXMuaXNBY3RpdmUgPSAhdGhpcy5pc0FjdGl2ZQoKICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHsKICAgICAgICB0aGlzLmlzRm9jdXNpbmcgPSB0cnVlCiAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJykKICAgICAgICB9CiAgICAgICAgaWYgKCF0aGlzLm9wdHMuaGlkZURyb3Bkb3duKSB7CiAgICAgICAgICB0aGlzLnNldERyb3Bkb3duU3RhdGUodHJ1ZSkKICAgICAgICB9CiAgICAgICAgLy8gUmVjb3JkIHRvIGNoZWNrIGlmIHZhbHVlIGRpZCBjaGFuZ2UgaW4gdGhlIGxhdGVyIHBoYXNlCiAgICAgICAgaWYgKHRoaXMubGF6eSkgewogICAgICAgICAgdGhpcy5iYWtEaXNwbGF5VGltZSA9IFN0cmluZyh0aGlzLmRpc3BsYXlUaW1lIHx8ICcnKQogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCAmJiAhdGhpcy5pbnB1dElzRW1wdHkpIHsKICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLiRyZWZzLmlucHV0LnNlbGVjdGlvbkVuZCA9PT0gdGhpcy5kaXNwbGF5VGltZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGZpcnN0IHNsb3QgaW5zdGVhZCBvZiB0aGUgd2hvbGUgdmFsdWUgc3RyaW5nIHdoZW4gdGFiYmVkIGluCiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFNsb3QoKQogICAgICAgICAgICB9CiAgICAgICAgICB9KQogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHsKICAgICAgICAgIHRoaXMuc2V0RHJvcGRvd25TdGF0ZShmYWxzZSkKICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWFudWFsSW5wdXQpIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCB0aGlzLmdldEZ1bGxEYXRhKCkpCiAgICAgICAgfQogICAgICAgIHRoaXMuaXNGb2N1c2luZyA9IGZhbHNlCiAgICAgICAgaWYgKHRoaXMubGF6eSkgewogICAgICAgICAgdGhpcy5maWxsVmFsdWVzKHRydWUpCiAgICAgICAgICB0aGlzLmJha0Rpc3BsYXlUaW1lID0gdW5kZWZpbmVkCiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAodGhpcy5yZXN0cmljdGVkSG91clJhbmdlICYmIHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID8gdGhpcy5mb3JjZUFwbVNlbGVjdGlvbigpIDogdGhpcy5lbXB0eUFwbVNlbGVjdGlvbigpCiAgICAgIH0KICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgdGhpcy5jaGVja0ZvckF1dG9TY3JvbGwoKQogICAgICB9CiAgICB9LAoKICAgIHNldERyb3Bkb3duU3RhdGUgKHRvU2hvdywgZnJvbVVzZXJDbGljayA9IGZhbHNlKSB7CiAgICAgIGlmICh0b1Nob3cpIHsKICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkpIHsKICAgICAgICAgIHRoaXMuYXBwZW5kRHJvcGRvd25Ub0JvZHkoKQogICAgICAgIH0KICAgICAgICB0aGlzLmtlZXBGb2N1c2luZygpCiAgICAgICAgaWYgKHRoaXMuYXV0b0RpcmVjdGlvbkVuYWJsZWQpIHsKICAgICAgICAgIHRoaXMuY2hlY2tEcm9wRGlyZWN0aW9uKCkKICAgICAgICB9CiAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSB0cnVlCiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpIAogICAgICAgIGlmIChmcm9tVXNlckNsaWNrKSB7CiAgICAgICAgICBpZiAodGhpcy5maXhlZERyb3Bkb3duQnV0dG9uKSB7CiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlCiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLiRlbWl0KCdibHVyJywgdGhpcy5nZXRGdWxsRGF0YSgpKQogICAgICAgICAgdGhpcy5jaGVja0ZvckF1dG9TY3JvbGwoKQogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnNob3dEcm9wZG93biA9IGZhbHNlCiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnLCB0aGlzLmdldEZ1bGxEYXRhKCkpCiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5KSB7CiAgICAgICAgICB0aGlzLnJlbW92ZURyb3Bkb3duRnJvbUJvZHkoKQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBhcHBlbmREcm9wZG93blRvQm9keSAoKSB7CiAgICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duCiAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdCiAgICAgIGlmIChib2R5ICYmIGRyb3Bkb3duKSB7CiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlRHJvcGRvd25Qb3MpCiAgICAgICAgZHJvcGRvd24uY2xhc3NMaXN0LmFkZCgndnVlX190aW1lLXBpY2tlci1kcm9wZG93bicpCiAgICAgICAgdGhpcy51cGRhdGVEcm9wZG93blBvcygpCiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChkcm9wZG93bikKICAgICAgfQogICAgfSwKCiAgICB1cGRhdGVEcm9wZG93blBvcyAoKSB7CiAgICAgIGlmICghdGhpcy5hcHBlbmRUb0JvZHkpIHsgcmV0dXJuIH0KICAgICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuZHJvcGRvd24KICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0KICAgICAgaWYgKGJvZHkgJiYgZHJvcGRvd24pIHsKICAgICAgICBjb25zdCBib3ggPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKQogICAgICAgIGlmICh0aGlzLmRyb3Bkb3duRGlyQ2xhc3MgPT09ICdkcm9wLXVwJykgewogICAgICAgICAgZHJvcGRvd24uc3R5bGUuYm90dG9tID0gYCR7d2luZG93LmlubmVySGVpZ2h0IC0gYm94Lnl9cHhgCiAgICAgICAgICBkcm9wZG93bi5zdHlsZS50b3AgPSAnYXV0bycKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZHJvcGRvd24uc3R5bGUudG9wID0gYCR7Ym94LnkgKyBib3guaGVpZ2h0fXB4YAogICAgICAgICAgZHJvcGRvd24uc3R5bGUuYm90dG9tID0gJ2F1dG8nCiAgICAgICAgfQogICAgICAgIGRyb3Bkb3duLnN0eWxlLmxlZnQgPSBgJHtib3gueH1weGAKICAgICAgfQogICAgfSwKCiAgICByZW1vdmVEcm9wZG93bkZyb21Cb2R5ICgpIHsKICAgICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuZHJvcGRvd24KICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0KICAgICAgaWYgKGJvZHkgJiYgZHJvcGRvd24gJiYgYm9keS5jb250YWlucyhkcm9wZG93bikpIHsKICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGRyb3Bkb3duKQogICAgICB9CiAgICAgIGlmIChkcm9wZG93bikgewogICAgICAgIGRyb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUoJ3Z1ZV9fdGltZS1waWNrZXItZHJvcGRvd24nKQogICAgICAgIGRyb3Bkb3duLnN0eWxlLnRvcCA9ICcnCiAgICAgICAgZHJvcGRvd24uc3R5bGUuYm90dG9tID0gJycKICAgICAgICBkcm9wZG93bi5zdHlsZS5sZWZ0ID0gJycKICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChkcm9wZG93bikKICAgICAgfQogICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVEcm9wZG93blBvcykKICAgIH0sCgogICAgYmx1ckV2ZW50ICgpIHsKICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQgJiYgIXRoaXMub3B0cy5oaWRlRHJvcGRvd24pIHsKICAgICAgICAvLyBoaWRlRHJvcGRvd24ncyBgYmx1cmAgZXZlbnQgaXMgaGFuZGxlZCBzb21ld2hlcmUgZWxzZQogICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCB0aGlzLmdldEZ1bGxEYXRhKCkpCiAgICAgIH0KICAgIH0sCgogICAgc2VsZWN0ICh0eXBlLCB2YWx1ZSkgewogICAgICBpZiAodGhpcy5pc0Jhc2ljVHlwZSh0eXBlKSAmJiAhdGhpcy5pc0Rpc2FibGVkKHR5cGUsIHZhbHVlKSkgewogICAgICAgIHRoaXNbdHlwZV0gPSB2YWx1ZQogICAgICAgIGlmICh0aGlzLmRvQ2xlYXJBcG1DaGVja2luZykgewogICAgICAgICAgdGhpcy5kb0NsZWFyQXBtQ2hlY2tpbmcgPSBmYWxzZQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBjbGVhclRpbWUgKCkgewogICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm4gfQogICAgICB0aGlzLmhvdXIgPSAnJwogICAgICB0aGlzLm1pbnV0ZSA9ICcnCiAgICAgIHRoaXMuc2Vjb25kID0gJycKICAgICAgdGhpcy5hcG0gPSAnJwoKICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQgJiYgdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmlucHV0ICYmIHRoaXMuJHJlZnMuaW5wdXQudmFsdWUubGVuZ3RoKSB7CiAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC52YWx1ZSA9ICcnCiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmxhenkpIHsKICAgICAgICB0aGlzLmZpbGxWYWx1ZXModHJ1ZSkKICAgICAgfQogICAgfSwKCiAgICAvLwogICAgLy8gQXV0by1TY3JvbGwKICAgIC8vCgogICAgY2hlY2tGb3JBdXRvU2Nyb2xsICgpIHsKICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7IHJldHVybiB9CiAgICAgIGlmICh0aGlzLmF1dG9TY3JvbGwpIHsKICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0ZWRWYWx1ZXMoKQogICAgICAgIH0pCiAgICAgIH0gZWxzZSBpZiAodGhpcy5hZHZhbmNlZEtleWJvYXJkKSB7CiAgICAgICAgLy8gQXV0by1mb2N1cyBvbiBzZWxlY3RlZCB2YWx1ZSBpbiB0aGUgZmlyc3QgY29sdW1uIGZvciBhZHZhbmNlZC1rZXlib2FyZAogICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgIGNvbnN0IGZpcnN0Q29sdW1uID0gdGhpcy5pblVzZS50eXBlc1swXQogICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGVkKGZpcnN0Q29sdW1uLCB0cnVlKQogICAgICAgIH0pCiAgICAgIH0KICAgIH0sCgogICAgc2Nyb2xsVG9TZWxlY3RlZCAoY29sdW1uLCBhbGxvd0ZhbGxiYWNrID0gZmFsc2UpIHsKICAgICAgaWYgKCF0aGlzLnRpbWVWYWx1ZSB8fCB0aGlzLmlucHV0SXNFbXB0eSkgeyByZXR1cm4gfQogICAgICBsZXQgdGFyZ2V0TGlzdAogICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duKSB7CiAgICAgICAgdGFyZ2V0TGlzdCA9IHRoaXMuJHJlZnMuZHJvcGRvd24ucXVlcnlTZWxlY3RvckFsbChgdWwuJHtjb2x1bW59c2ApWzBdCiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFyZ2V0TGlzdCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoYHVsLiR7Y29sdW1ufXNgKVswXQogICAgICB9CiAgICAgIGxldCB0YXJnZXRWYWx1ZSA9IHRoaXMuYWN0aXZlSXRlbUluQ29sKGNvbHVtbilbMF0KICAgICAgaWYgKCF0YXJnZXRWYWx1ZSAmJiBhbGxvd0ZhbGxiYWNrKSB7CiAgICAgICAgLy8gTm8gdmFsdWUgc2VsZWN0ZWQgaW4gdGhlIHRhcmdldCBjb2x1bW4sIGZhbGxiYWNrIHRvIHRoZSBmaXJzdCBmb3VuZCB2YWxpZCBpdGVtCiAgICAgICAgdGFyZ2V0VmFsdWUgPSB0aGlzLnZhbGlkSXRlbXNJbkNvbChjb2x1bW4pWzBdCiAgICAgIH0KICAgICAgaWYgKHRhcmdldExpc3QgJiYgdGFyZ2V0VmFsdWUpIHsKICAgICAgICB0YXJnZXRMaXN0LnNjcm9sbFRvcCA9IHRhcmdldFZhbHVlLm9mZnNldFRvcCB8fCAwCiAgICAgICAgaWYgKHRoaXMuYWR2YW5jZWRLZXlib2FyZCkgewogICAgICAgICAgdGFyZ2V0VmFsdWUuZm9jdXMoKQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBzY3JvbGxUb1NlbGVjdGVkVmFsdWVzICgpIHsKICAgICAgaWYgKCF0aGlzLnRpbWVWYWx1ZSB8fCB0aGlzLmlucHV0SXNFbXB0eSkgeyByZXR1cm4gfQogICAgICB0aGlzLmluVXNlLnR5cGVzLmZvckVhY2goc2VjdGlvbiA9PiB7CiAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGVkKHNlY3Rpb24pCiAgICAgIH0pCiAgICB9LAoKICAgIC8vCiAgICAvLyBBZGRpdGlvbmFsIEtleWJvYXJkIE5hdmlnYXRpb24KICAgIC8vCgogICAgb25Gb2N1cyAoKSB7CiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybiB9CiAgICAgIGlmICghdGhpcy5pc0ZvY3VzaW5nKSB7CiAgICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gdHJ1ZQogICAgICB9CiAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkgewogICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlKCkKICAgICAgfQogICAgfSwKCiAgICBlc2NCbHVyICgpIHsKICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICAgIHRoaXMuaXNGb2N1c2luZyA9IGZhbHNlCiAgICAgIGNvbnN0IGlucHV0Qm94ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQuZGlzcGxheS10aW1lJylbMF0KICAgICAgaWYgKGlucHV0Qm94KSB7CiAgICAgICAgaW5wdXRCb3guYmx1cigpCiAgICAgIH0KICAgIH0sCgogICAgZGVib3VuY2VCbHVyICgpIHsKICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gZmFsc2UKICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICAgIHRoaXMuZGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VUaW1lcikKICAgICAgICB0aGlzLm9uQmx1cigpCiAgICAgIH0sIHRoaXMub3B0cy5ibHVyRGVsYXkpCiAgICB9LAoKICAgIG9uQmx1ciAoKSB7CiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhdGhpcy5pc0ZvY3VzaW5nICYmIHRoaXMuaXNBY3RpdmUpIHsKICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZSgpCiAgICAgIH0KICAgIH0sCgogICAga2VlcEZvY3VzaW5nICgpIHsKICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICAgIGlmICghdGhpcy5pc0ZvY3VzaW5nKSB7CiAgICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gdHJ1ZQogICAgICB9CiAgICB9LAoKICAgIG9uVGFiIChjb2x1bW4sIHZhbHVlLCBldnQpIHsKICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIGV2dC5zaGlmdEtleSkgewogICAgICAgIGNvbnN0IGZpcnN0Q29sdW1uID0gdGhpcy5pblVzZS50eXBlc1swXQogICAgICAgIGlmIChjb2x1bW4gIT09IGZpcnN0Q29sdW1uKSB7IHJldHVybiB9CiAgICAgICAgY29uc3QgZmlyc3RWYWxpZFZhbHVlID0gdGhpcy52YWxpZEl0ZW1zSW5Db2woZmlyc3RDb2x1bW4pWzBdCiAgICAgICAgLy8gSXMgdGhlIGZpcnN0IHZhbGlkIGl0ZW0gaW4gdGhlIGZpcnN0IGNvbHVtbgogICAgICAgIGlmIChmaXJzdFZhbGlkVmFsdWUgJiYgZmlyc3RWYWxpZFZhbHVlLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKSA9PT0gU3RyaW5nKHZhbHVlKSkgewogICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCkKICAgICAgICAgIC8vIEZvY3VzIGJhY2sgb24gPGlucHV0PgogICAgICAgICAgaWYgKHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5pbnB1dCkgewogICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LmZvY3VzKCkKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0sCgogICAgdmFsaWRJdGVtc0luQ29sIChjb2x1bW4pIHsKICAgICAgY29uc3QgY29sdW1uQ2xhc3MgPSBgJHtjb2x1bW59c2AKICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bikgewogICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoYHVsLiR7Y29sdW1uQ2xhc3N9ID4gbGk6bm90KC5oaW50KTpub3QoW2Rpc2FibGVkXSlgKQogICAgICB9CiAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbkNsYXNzfSA+IGxpOm5vdCguaGludCk6bm90KFtkaXNhYmxlZF0pYCkKICAgIH0sCgogICAgYWN0aXZlSXRlbUluQ29sIChjb2x1bW4pIHsKICAgICAgY29uc3QgY29sdW1uQ2xhc3MgPSBgJHtjb2x1bW59c2AKICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bikgewogICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoYHVsLiR7Y29sdW1uQ2xhc3N9ID4gbGkuYWN0aXZlOm5vdCguaGludClgKQogICAgICB9CiAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbkNsYXNzfSA+IGxpLmFjdGl2ZTpub3QoLmhpbnQpYCkKICAgIH0sCgogICAgZ2V0Q2xvc2VzdFNpYmxpbmcgKGNvbHVtbiwgZGF0YUtleSwgZ2V0UHJldmlvdXMgPSBmYWxzZSkgewogICAgICBjb25zdCBzaWJsaW5nc0luQ29sID0gdGhpcy52YWxpZEl0ZW1zSW5Db2woY29sdW1uKQogICAgICBjb25zdCBzZWxmSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwoc2libGluZ3NJbkNvbCwgKHNibCkgPT4gewogICAgICAgIHJldHVybiBzYmwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpID09PSBkYXRhS2V5CiAgICAgIH0pCgogICAgICAvLyBBbHJlYWR5IHRoZSBmaXJzdCBpdGVtCiAgICAgIGlmIChnZXRQcmV2aW91cyAmJiBzZWxmSW5kZXggPT09IDApIHsKICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFtzaWJsaW5nc0luQ29sLmxlbmd0aCAtIDFdCiAgICAgIH0KICAgICAgLy8gQWxyZWFkeSB0aGUgbGFzdCBpdGVtCiAgICAgIGlmICghZ2V0UHJldmlvdXMgJiYgc2VsZkluZGV4ID09PSBzaWJsaW5nc0luQ29sLmxlbmd0aCAtIDEpIHsKICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFswXQogICAgICB9CiAgICAgIC8vIFNlbGVjdGVkIHZhbHVlIG5vdCBpbiB0aGUgdmFsaWQgdmFsdWVzIGxpc3QKICAgICAgaWYgKHNlbGZJbmRleCA8IDApIHsKICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFswXQogICAgICB9CgogICAgICBpZiAoZ2V0UHJldmlvdXMpIHsKICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFtzZWxmSW5kZXggLSAxXQogICAgICB9CiAgICAgIHJldHVybiBzaWJsaW5nc0luQ29sW3NlbGZJbmRleCArIDFdCiAgICB9LAoKICAgIHByZXZJdGVtIChjb2x1bW4sIGRhdGFLZXksIGlzTWFudWFsSW5wdXQgPSBmYWxzZSkgewogICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5nZXRDbG9zZXN0U2libGluZyhjb2x1bW4sIGRhdGFLZXksIHRydWUpCiAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgcmV0dXJuIGlzTWFudWFsSW5wdXQgPyB0YXJnZXRJdGVtIDogdGFyZ2V0SXRlbS5mb2N1cygpCiAgICAgIH0KICAgIH0sCgogICAgbmV4dEl0ZW0gKGNvbHVtbiwgZGF0YUtleSwgaXNNYW51YWxJbnB1dCA9IGZhbHNlKSB7CiAgICAgIGNvbnN0IHRhcmdldEl0ZW0gPSB0aGlzLmdldENsb3Nlc3RTaWJsaW5nKGNvbHVtbiwgZGF0YUtleSwgZmFsc2UpCiAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgcmV0dXJuIGlzTWFudWFsSW5wdXQgPyB0YXJnZXRJdGVtIDogdGFyZ2V0SXRlbS5mb2N1cygpCiAgICAgIH0KICAgIH0sCgogICAgZ2V0U2lkZUNvbHVtbk5hbWUgKGN1cnJlbnRDb2x1bW4sIHRvTGVmdCA9IGZhbHNlKSB7CiAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW5JbmRleCA9IHRoaXMuaW5Vc2UudHlwZXMuaW5kZXhPZihjdXJyZW50Q29sdW1uKQogICAgICBpZiAodG9MZWZ0ICYmIGN1cnJlbnRDb2x1bW5JbmRleCA8PSAwKSB7CiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSBsZWZ0bW9zdCBsaXN0IGFscmVhZHknKQogICAgICAgIH0KICAgICAgICByZXR1cm4KICAgICAgfSBlbHNlIGlmICghdG9MZWZ0ICYmIGN1cnJlbnRDb2x1bW5JbmRleCA9PT0gKHRoaXMuaW5Vc2UudHlwZXMubGVuZ3RoIC0gMSkpIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coJ1lvdVwncmUgaW4gdGhlIHJpZ2h0bW9zdCBsaXN0IGFscmVhZHknKQogICAgICAgIH0KICAgICAgICByZXR1cm4KICAgICAgfQogICAgICByZXR1cm4gdGhpcy5pblVzZS50eXBlc1t0b0xlZnQgPyBjdXJyZW50Q29sdW1uSW5kZXggLSAxIDogY3VycmVudENvbHVtbkluZGV4ICsgMV0KICAgIH0sCgogICAgZ2V0Rmlyc3RJdGVtSW5TaWRlQ29sdW1uIChjdXJyZW50Q29sdW1uLCB0b0xlZnQgPSBmYWxzZSkgewogICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSB0aGlzLmdldFNpZGVDb2x1bW5OYW1lKGN1cnJlbnRDb2x1bW4sIHRvTGVmdCkKICAgICAgaWYgKCF0YXJnZXRDb2x1bW4pIHsgcmV0dXJuIH0KICAgICAgY29uc3QgbGlzdEl0ZW1zID0gdGhpcy52YWxpZEl0ZW1zSW5Db2wodGFyZ2V0Q29sdW1uKQogICAgICBpZiAobGlzdEl0ZW1zICYmIGxpc3RJdGVtc1swXSkgewogICAgICAgIHJldHVybiBsaXN0SXRlbXNbMF0KICAgICAgfQogICAgfSwKCiAgICBnZXRBY3RpdmVJdGVtSW5TaWRlQ29sdW1uIChjdXJyZW50Q29sdW1uLCB0b0xlZnQgPSBmYWxzZSkgewogICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSB0aGlzLmdldFNpZGVDb2x1bW5OYW1lKGN1cnJlbnRDb2x1bW4sIHRvTGVmdCkKICAgICAgaWYgKCF0YXJnZXRDb2x1bW4pIHsgcmV0dXJuIH0KICAgICAgY29uc3QgYWN0aXZlSXRlbXMgPSB0aGlzLmFjdGl2ZUl0ZW1JbkNvbCh0YXJnZXRDb2x1bW4pCiAgICAgIGlmIChhY3RpdmVJdGVtcyAmJiBhY3RpdmVJdGVtc1swXSkgewogICAgICAgIHJldHVybiBhY3RpdmVJdGVtc1swXQogICAgICB9CiAgICB9LAoKICAgIHRvTGVmdENvbHVtbiAoY3VycmVudENvbHVtbikgewogICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5nZXRBY3RpdmVJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIHRydWUpIHx8IHRoaXMuZ2V0Rmlyc3RJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIHRydWUpCiAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgdGFyZ2V0SXRlbS5mb2N1cygpCiAgICAgIH0KICAgIH0sCgogICAgdG9SaWdodENvbHVtbiAoY3VycmVudENvbHVtbikgewogICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5nZXRBY3RpdmVJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIGZhbHNlKSB8fCB0aGlzLmdldEZpcnN0SXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uLCBmYWxzZSkKICAgICAgaWYgKHRhcmdldEl0ZW0pIHsKICAgICAgICB0YXJnZXRJdGVtLmZvY3VzKCkKICAgICAgfQogICAgfSwKCiAgICAvLwogICAgLy8gTWFudWFsIElucHV0CiAgICAvLwoKICAgIG9uTW91c2VEb3duICgpIHsKICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7IHJldHVybiB9CiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgdGhpcy5zZWxlY3Rpb25UaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICAgICAgaWYgKHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5pbnB1dCkgewogICAgICAgICAgY29uc3QgbmVhcmVzdFNsb3QgPSB0aGlzLmdldE5lYXJlc3RDaHVua0J5UG9zKHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgMCkKICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZWFyZXN0U2xvdCkKICAgICAgICB9CiAgICAgIH0sIDUwKQogICAgfSwKCiAgICBrZXlEb3duSGFuZGxlciAoZXZ0KSB7CiAgICAgIGlmIChldnQuaXNDb21wb3NpbmcgfHwgZXZ0LmtleUNvZGUgPT09IDIyOSkgewogICAgICAgIC8vIFNraXAgSU1FIGlucHV0cwogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpCiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgLy8gTnVtYmVycwogICAgICBpZiAoKGV2dC5rZXlDb2RlID49IDQ4ICYmIGV2dC5rZXlDb2RlIDw9IDU3KSB8fCAoZXZ0LmtleUNvZGUgPj0gOTYgJiYgZXZ0LmtleUNvZGUgPD0gMTA1KSkgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgdGhpcy5rZXlib2FyZElucHV0KGV2dC5rZXkpCiAgICAgIC8vIEF8UHxNCiAgICAgIH0gZWxzZSBpZiAoWzY1LCA4MCwgNzddLmluY2x1ZGVzKGV2dC5rZXlDb2RlKSkgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgdGhpcy5rZXlib2FyZElucHV0KGV2dC5rZXksIHRydWUpCiAgICAgIC8vIEFycm93IGtleXMKICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA+PSAzNyAmJiBldnQua2V5Q29kZSA8PSA0MCkgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgdGhpcy5jbGVhcktiSW5wdXRMb2coKQogICAgICAgIHRoaXMuYXJyb3dIYW5kbGVyKGV2dCkKICAgICAgLy8gRGVsZXRlfEJhY2tzcGFjZQogICAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlID09PSA4IHx8IGV2dC5rZXlDb2RlID09PSA0NikgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgdGhpcy5jbGVhcktiSW5wdXRMb2coKQogICAgICAgIHRoaXMuY2xlYXJUaW1lKCkKICAgICAgLy8gVGFiCiAgICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT09IDkpIHsKICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpCiAgICAgICAgdGhpcy50YWJIYW5kbGVyKGV2dCkKICAgICAgLy8gQ29sb258U3BhY2UKICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gMTg2IHx8IGV2dC5rZXlDb2RlID09PSAzMikgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgdGhpcy5jbGVhcktiSW5wdXRMb2coKQogICAgICAgIHRoaXMudG9OZXh0U2xvdCgpCiAgICAgIC8vIFByZXZlbnQgYW55IE5vbi1FU0MgYW5kIG5vbi1wYXN0aW5nIGlucHV0cwogICAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlICE9PSAyNyAmJiAhKGV2dC5tZXRhS2V5IHx8IGV2dC5jdHJsS2V5KSkgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgIH0KICAgIH0sCgogICAgb25Db21wb3N0aW9uU3RhcnQgKGV2dCkgewogICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCkKICAgICAgdGhpcy5iYWtDdXJyZW50UG9zID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgIHJldHVybiBmYWxzZQogICAgfSwKCiAgICBvbkNvbXBvc3Rpb25FbmQgKGV2dCkgewogICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCkKCiAgICAgIGNvbnN0IGNwc0RhdGEgPSBldnQuZGF0YQogICAgICBsZXQgaW5wdXRJc0N1c3RvbUFwbVRleHQgPSBmYWxzZQogICAgICBpZiAodGhpcy5oYXMuY3VzdG9tQXBtVGV4dCkgewogICAgICAgIGlucHV0SXNDdXN0b21BcG1UZXh0ID0gdGhpcy5pc0N1c3RvbUFwbVRleHQoY3BzRGF0YSkKICAgICAgfQogICAgICBpZiAoaW5wdXRJc0N1c3RvbUFwbVRleHQpIHsKICAgICAgICB0aGlzLnNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKCdhcG0nLCBpbnB1dElzQ3VzdG9tQXBtVGV4dCkKICAgICAgfQoKICAgICAgdGhpcy4kcmVmcy5pbnB1dC52YWx1ZSA9IHRoaXMuaGFzLmN1c3RvbUFwbVRleHQgPyB0aGlzLmN1c3RvbURpc3BsYXlUaW1lIDogdGhpcy5kaXNwbGF5VGltZQoKICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgIGlmICh0aGlzLmJha0N1cnJlbnRQb3MpIHsKICAgICAgICAgIGNvbnN0IGJha1BvcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5iYWtDdXJyZW50UG9zKSkKICAgICAgICAgIGlmIChpbnB1dElzQ3VzdG9tQXBtVGV4dCkgewogICAgICAgICAgICBiYWtQb3MuZW5kID0gKGJha1Bvcy5zdGFydCArIGNwc0RhdGEubGVuZ3RoKQogICAgICAgICAgfQogICAgICAgICAgdGhpcy5kZWJvdW5jZVNldElucHV0U2VsZWN0aW9uKGJha1BvcykKICAgICAgICAgIHRoaXMuYmFrQ3VycmVudFBvcyA9IG51bGwKICAgICAgICB9CiAgICAgIH0pCiAgICAgIHJldHVybiBmYWxzZQogICAgfSwKCiAgICBwYXN0ZUhhbmRsZXIgKGV2dCkgewogICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICBsZXQgcGFzdGluZ1RleHQgPSAoZXZ0LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGEpLmdldERhdGEoJ3RleHQnKQogICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICB0aGlzLmRlYnVnTG9nKGBQYXN0aW5nIHZhbHVlICIke3Bhc3RpbmdUZXh0fSIgZnJvbSBjbGlwYm9hcmRgKQogICAgICB9CiAgICAgIGlmICghcGFzdGluZ1RleHQgfHwgIXBhc3RpbmdUZXh0Lmxlbmd0aCkgeyByZXR1cm4gfQoKICAgICAgLy8gUmVwbGFjZSBjdXN0b20gQU0vUE0gdGV4dCAoaWYgYW55KQogICAgICBpZiAodGhpcy5oYXMuY3VzdG9tQXBtVGV4dCkgewogICAgICAgIHBhc3RpbmdUZXh0ID0gdGhpcy5yZXBsYWNlQ3VzdG9tQXBtVGV4dChwYXN0aW5nVGV4dCkKICAgICAgfQoKICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgdGhpcy5yZWFkU3RyaW5nVmFsdWVzKHBhc3RpbmdUZXh0KQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMua2JJbnB1dExvZyA9IHBhc3RpbmdUZXh0LnN1YnN0cigtMiwgMikKICAgICAgICB0aGlzLnNldEtiSW5wdXQoKQogICAgICAgIHRoaXMuZGVib3VuY2VDbGVhcktiTG9nKCkKICAgICAgfQogICAgfSwKCiAgICBhcnJvd0hhbmRsZXIgKGV2dCkgewogICAgICBjb25zdCBkaXJlY3Rpb24gPSB7IDM3OiAnTCcsIDM4OiAnVScsIDM5OiAnUicsIDQwOiAnRCcgfVtldnQua2V5Q29kZV0KICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ1UnIHx8IGRpcmVjdGlvbiA9PT0gJ0QnKSB7CiAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICB0aGlzLnNlbGVjdEZpcnN0VmFsaWRWYWx1ZSgpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICAgICAgaWYgKCFjdXJyZW50Q2h1bmspIHsKICAgICAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFZhbGlkVmFsdWUoKQogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IGN1cnJlbnRDaHVuay50eXBlCiAgICAgICAgICB0aGlzLmdldENsb3Nlc3RWYWxpZEl0ZW1JbkNvbCh0b2tlblR5cGUsIHRoaXNbdG9rZW5UeXBlXSwgZGlyZWN0aW9uKQogICAgICAgICAgY29uc3QgbmV3Q2h1bmtQb3MgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZXdDaHVua1BvcykKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnUicpIHsKICAgICAgICB0aGlzLnRvTGF0ZXJhbFRva2VuKGZhbHNlKQogICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ0wnKSB7CiAgICAgICAgdGhpcy50b0xhdGVyYWxUb2tlbih0cnVlKQogICAgICB9CiAgICB9LAoKICAgIHRhYkhhbmRsZXIgKGV2dCkgewogICAgICBpZiAoIXRoaXMuaW5wdXRJc0VtcHR5ICYmIHRoaXMudG9rZW5DaHVua3NQb3MgJiYgdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGgpIHsKICAgICAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICBpZiAoIWN1cnJlbnRDaHVuaykgeyByZXR1cm4gfQogICAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSB0aGlzLnRva2VuQ2h1bmtzUG9zWzBdCiAgICAgICAgY29uc3QgbGFzdENodW5rID0gdGhpcy50b2tlbkNodW5rc1Bvc1t0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCAtIDFdCiAgICAgICAgaWYgKChldnQuc2hpZnRLZXkgJiYgY3VycmVudENodW5rLnRva2VuICE9PSBmaXJzdENodW5rLnRva2VuKSB8fCAoIWV2dC5zaGlmdEtleSAmJiBjdXJyZW50Q2h1bmsudG9rZW4gIT09IGxhc3RDaHVuay50b2tlbikpIHsKICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICB0aGlzLnRvTGF0ZXJhbFRva2VuKGV2dC5zaGlmdEtleSkKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgdGhpcy5hZHZhbmNlZEtleWJvYXJkKSB7CiAgICAgICAgaWYgKGV2dC5zaGlmdEtleSkgeyByZXR1cm4gfQogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICBjb25zdCBmaXJzdENvbHVtbiA9IHRoaXMuaW5Vc2UudHlwZXNbMF0KICAgICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGhpcy52YWxpZEl0ZW1zSW5Db2woZmlyc3RDb2x1bW4pWzBdCiAgICAgICAgICBpZiAodGFyZ2V0VmFsdWUpIHsKICAgICAgICAgICAgdGFyZ2V0VmFsdWUuZm9jdXMoKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBrZXlib2FyZElucHV0IChuZXdDaGFyLCBpc0FwbSA9IGZhbHNlKSB7CiAgICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICBpZiAoIWN1cnJlbnRDaHVuayB8fCAoY3VycmVudENodW5rLnR5cGUgIT09ICdhcG0nICYmIGlzQXBtKSB8fCAoY3VycmVudENodW5rLnR5cGUgPT09ICdhcG0nICYmICFpc0FwbSkpIHsgcmV0dXJuIH0KICAgICAgdGhpcy5rYklucHV0TG9nID0gYCR7dGhpcy5rYklucHV0TG9nLnN1YnN0cigtMSl9JHtuZXdDaGFyfWAKICAgICAgdGhpcy5zZXRLYklucHV0KCkKICAgICAgdGhpcy5kZWJvdW5jZUNsZWFyS2JMb2coKQogICAgfSwKCiAgICBjbGVhcktiSW5wdXRMb2cgKCkgewogICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogICAgICB0aGlzLmtiSW5wdXRMb2cgPSAnJwogICAgfSwKCiAgICBkZWJvdW5jZUNsZWFyS2JMb2cgKCkgewogICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogICAgICB0aGlzLmtiSW5wdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpCiAgICAgIH0sIHRoaXMub3B0cy5tYW51YWxJbnB1dFRpbWVvdXQpCiAgICB9LAoKICAgIHNldEtiSW5wdXQgKHZhbHVlKSB7CiAgICAgIHZhbHVlID0gdmFsdWUgfHwgdGhpcy5rYklucHV0TG9nCiAgICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICBpZiAoIWN1cnJlbnRDaHVuayB8fCAhdmFsdWUgfHwgIXZhbHVlLmxlbmd0aCkgeyByZXR1cm4gfQogICAgICBjb25zdCBjaHVua1R5cGUgPSBjdXJyZW50Q2h1bmsudHlwZQogICAgICBjb25zdCBjaHVua1Rva2VuID0gY3VycmVudENodW5rLnRva2VuCgogICAgICBsZXQgdmFsaWRWYWx1ZQogICAgICBpZiAoY2h1bmtUeXBlID09PSAnYXBtJykgewogICAgICAgIGlmICh0aGlzLmxvd2VyQ2FzZWRBcG0odmFsdWUpLmluY2x1ZGVzKCdhJykpIHsKICAgICAgICAgIHZhbGlkVmFsdWUgPSAnYW0nCiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxvd2VyQ2FzZWRBcG0odmFsdWUpLmluY2x1ZGVzKCdwJykpIHsKICAgICAgICAgIHZhbGlkVmFsdWUgPSAncG0nCiAgICAgICAgfQogICAgICAgIGlmICh2YWxpZFZhbHVlKSB7CiAgICAgICAgICB2YWxpZFZhbHVlID0gY2h1bmtUb2tlbiA9PT0gJ0EnID8gdmFsaWRWYWx1ZS50b1VwcGVyQ2FzZSgpIDogdmFsaWRWYWx1ZQogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUoY2h1bmtUb2tlbiwgdmFsdWUpKSB7CiAgICAgICAgICB2YWxpZFZhbHVlID0gdmFsdWUKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3QgbGFzdElucHV0VmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKGNodW5rVG9rZW4sIHZhbHVlLnN1YnN0cigtMSkpCiAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUoY2h1bmtUb2tlbiwgbGFzdElucHV0VmFsdWUpKSB7CiAgICAgICAgICAgIHZhbGlkVmFsdWUgPSBsYXN0SW5wdXRWYWx1ZQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHZhbGlkVmFsdWUpIHsKICAgICAgICB0aGlzLnNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKGNodW5rVHlwZSwgdmFsaWRWYWx1ZSkKICAgICAgICBjb25zdCBuZXdDaHVua1BvcyA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZXdDaHVua1BvcykgICAgICAKICAgICAgfQogICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICBpZiAodmFsaWRWYWx1ZSkgewogICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgU3VjY2Vzc2Z1bGx5IHNldCB2YWx1ZSAiJHt2YWxpZFZhbHVlfSIgZnJvbSBsYXRlc3QgaW5wdXQgIiR7dmFsdWV9IiBmb3IgdGhlICIke2NodW5rVHlwZX0iIHNsb3RgKQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBWYWx1ZSAiJHt2YWx1ZX0iIGlzIGludmFsaWQgaW4gdGhlICIke2NodW5rVHlwZX0iIHNsb3RgKQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICAvLyBGb3JtIEF1dG9maWxsCiAgICBvbkNoYW5nZSAoKSB7CiAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCB8fCAhdGhpcy4kcmVmcyB8fCAhdGhpcy4kcmVmcy5pbnB1dCkgeyByZXR1cm4gfQogICAgICBjb25zdCBhdXRvRmlsbFZhbHVlID0gdGhpcy4kcmVmcy5pbnB1dC52YWx1ZSB8fCAnJwogICAgICBpZiAoYXV0b0ZpbGxWYWx1ZSAmJiBhdXRvRmlsbFZhbHVlLmxlbmd0aCkgewogICAgICAgIHRoaXMucmVhZFN0cmluZ1ZhbHVlcyhhdXRvRmlsbFZhbHVlKQogICAgICB9CiAgICB9LAoKICAgIGdldE5lYXJlc3RDaHVua0J5UG9zIChzdGFydFBvcykgewogICAgICBpZiAoIXRoaXMudG9rZW5DaHVua3NQb3MgfHwgIXRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoKSB7IHJldHVybiB9CiAgICAgIGxldCBuZWFyZXN0CiAgICAgIGxldCBuZWFyZXN0RGVsdGEgPSAtMQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBjaHVuayA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy50b2tlbkNodW5rc1Bvc1tpXSkpCiAgICAgICAgaWYgKGNodW5rLnN0YXJ0ID09PSBzdGFydFBvcykgewogICAgICAgICAgcmV0dXJuIGNodW5rCiAgICAgICAgfQogICAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5hYnMoY2h1bmsuc3RhcnQgLSBzdGFydFBvcykKICAgICAgICBpZiAobmVhcmVzdERlbHRhIDwgMCkgewogICAgICAgICAgbmVhcmVzdCA9IGNodW5rCiAgICAgICAgICBuZWFyZXN0RGVsdGEgPSBkZWx0YQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAobmVhcmVzdERlbHRhIDw9IGRlbHRhKSB7CiAgICAgICAgICAgIHJldHVybiBuZWFyZXN0CiAgICAgICAgICB9CiAgICAgICAgICBuZWFyZXN0RGVsdGEgPSBkZWx0YQogICAgICAgICAgbmVhcmVzdCA9IGNodW5rCiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBuZWFyZXN0CiAgICB9LAoKICAgIHNlbGVjdEZpcnN0VmFsaWRWYWx1ZSAoKSB7CiAgICAgIGlmICghdGhpcy50b2tlbkNodW5rc1BvcyB8fCAhdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGgpIHsgcmV0dXJuIH0KICAgICAgY29uc3QgZmlyc3RTbG90VHlwZSA9IHRoaXMudG9rZW5DaHVua3NQb3NbMF0udHlwZQogICAgICBpZiAoZmlyc3RTbG90VHlwZSA9PT0gJ2hvdXInKSB7CiAgICAgICAgdGhpcy5nZXRDbG9zZXN0SG91ckl0ZW0oKQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuZ2V0Q2xvc2VzdFZhbGlkSXRlbUluQ29sKGZpcnN0U2xvdFR5cGUsIHRoaXNbZmlyc3RTbG90VHlwZV0pCiAgICAgIH0KICAgICAgdGhpcy5zZWxlY3RGaXJzdFNsb3QoKQogICAgfSwKCiAgICBnZXRDbG9zZXN0SG91ckl0ZW0gKGN1cnJlbnRWYWx1ZSwgZGlyZWN0aW9uID0gJ1UnKSB7CiAgICAgIGlmICghdGhpcy52YWxpZEhvdXJzTGlzdCB8fCAhdGhpcy52YWxpZEhvdXJzTGlzdC5sZW5ndGgpIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5vIHZhbGlkIGhvdXIgdmFsdWVzIGZvdW5kLCBwbGVhc2UgY2hlY2sgeW91ciAiaG91ci1yYW5nZSIgY29uZmlnXG5ob3VyLXJhbmdlOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuaG91clJhbmdlKX1gKQogICAgICAgIH0KICAgICAgICByZXR1cm4KICAgICAgfQogICAgICBpZiAoIWN1cnJlbnRWYWx1ZSkgewogICAgICAgIHRoaXMuc2V0TWFudWFsSG91cih0aGlzLnZhbGlkSG91cnNMaXN0WzBdKQogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMudmFsaWRIb3Vyc0xpc3QuZmluZEluZGV4KGl0ZW0gPT4gewogICAgICAgIGlmICghdGhpcy5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgICByZXR1cm4gaXRlbSA9PT0gY3VycmVudFZhbHVlCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gYCR7Y3VycmVudFZhbHVlfSR7dGhpcy5sb3dlckNhc2VkQXBtKHRoaXMuYXBtKSA9PT0gJ3BtJyA/ICdwJyA6ICdhJ31gIAogICAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHZhbHVlS2V5CiAgICAgICAgfQogICAgICB9KQogICAgICBsZXQgbmV4dEluZGV4CiAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7CiAgICAgICAgbmV4dEluZGV4ID0gMAogICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ0QnKSB7CiAgICAgICAgbmV4dEluZGV4ID0gY3VycmVudEluZGV4ID09PSAwID8gdGhpcy52YWxpZEhvdXJzTGlzdC5sZW5ndGggLSAxIDogY3VycmVudEluZGV4IC0gMQogICAgICB9IGVsc2UgewogICAgICAgIG5leHRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIHRoaXMudmFsaWRIb3Vyc0xpc3QubGVuZ3RoCiAgICAgIH0KICAgICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLnZhbGlkSG91cnNMaXN0W25leHRJbmRleF0KICAgICAgdGhpcy5zZXRNYW51YWxIb3VyKG5leHRJdGVtKQogICAgfSwKCiAgICBnZXRDbG9zZXN0VmFsaWRJdGVtSW5Db2wgKGNvbHVtbiwgY3VycmVudFZhbHVlLCBkaXJlY3Rpb24gPSAnVScpIHsKICAgICAgaWYgKGNvbHVtbiA9PT0gJ2hvdXInKSB7CiAgICAgICAgdGhpcy5nZXRDbG9zZXN0SG91ckl0ZW0oY3VycmVudFZhbHVlLCBkaXJlY3Rpb24pCiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSBkaXJlY3Rpb24gPT09ICdEJyA/IHRoaXMucHJldkl0ZW0oY29sdW1uLCB0aGlzW2NvbHVtbl0sIHRydWUpIDogdGhpcy5uZXh0SXRlbShjb2x1bW4sIHRoaXNbY29sdW1uXSwgdHJ1ZSkKICAgICAgICBpZiAobmV4dEl0ZW0pIHsKICAgICAgICAgIHRoaXMuc2VsZWN0KGNvbHVtbiwgbmV4dEl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpKQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBzZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbiAoc2VjdGlvbiwgaW5wdXRWYWx1ZSkgewogICAgICBpZiAoIXNlY3Rpb24gfHwgIXRoaXMuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbikpIHsgcmV0dXJuIH0KICAgICAgLy8gTk9URTogRGlzYWJsZWQgdmFsdWVzIGFyZSBhbGxvd2VkIGhlcmUsIGZvbGxvd2VkIGJ5IGFuICdlcnJvcicgZXZlbnQsIHRob3VnaAogICAgICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IHRoaXMuc2FuaXRpemVkVmFsdWUodGhpcy5nZXRUb2tlbkJ5VHlwZShzZWN0aW9uKSwgaW5wdXRWYWx1ZSkKICAgICAgdGhpc1tzZWN0aW9uXSA9IHNhbml0aXplZFZhbHVlCiAgICB9LAoKICAgIHNldE1hbnVhbEhvdXIgKG5leHRJdGVtKSB7CiAgICAgIGlmICh0aGlzLmlzMTJoUmFuZ2UobmV4dEl0ZW0pKSB7CiAgICAgICAgY29uc3QgaG91clQgPSB0aGlzLm1hdGNoMTJoUmFuZ2UobmV4dEl0ZW0pCiAgICAgICAgY29uc3QgYXBtVmFsdWUgPSBob3VyVFsyXSA9PT0gJ2EnID8gJ0FNJyA6ICdQTScKICAgICAgICB0aGlzLnNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKCdhcG0nLCB0aGlzLmFwbVR5cGUgPT09ICdhJyA/IGFwbVZhbHVlLnRvTG93ZXJDYXNlKCkgOiBhcG1WYWx1ZSkKICAgICAgICB0aGlzLnNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKCdob3VyJywgaG91clRbMV0pCiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbignaG91cicsIG5leHRJdGVtKQogICAgICB9CiAgICB9LAoKICAgIGRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24gKHtzdGFydCA9IDAsIGVuZCA9IDAgfSkgewogICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgdGhpcy5zZXRJbnB1dFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpCiAgICAgIH0pCiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgdGhpcy5zZWxlY3Rpb25UaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICAgICAgLy8gRG91YmxlLWNoZWNrIHNlbGVjdGlvbiBmb3IgMTJociBmb3JtYXQKICAgICAgICBpZiAodGhpcy4kcmVmcy5pbnB1dCAmJiAodGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25TdGFydCAhPT0gc3RhcnQgfHwgdGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25FbmQgIT09IGVuZCkpIHsKICAgICAgICAgIHRoaXMuc2V0SW5wdXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKQogICAgICAgIH0KICAgICAgfSwgMzApCiAgICB9LAoKICAgIHNldElucHV0U2VsZWN0aW9uUmFuZ2UgKHN0YXJ0LCBlbmQpIHsKICAgICAgaWYgKHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5pbnB1dCkgewogICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCkKICAgICAgfQogICAgfSwKCiAgICBnZXRDdXJyZW50VG9rZW5DaHVuayAoKSB7CiAgICAgIHJldHVybiB0aGlzLmdldE5lYXJlc3RDaHVua0J5UG9zKCh0aGlzLiRyZWZzLmlucHV0ICYmIHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uU3RhcnQpIHx8IDApCiAgICB9LAoKICAgIHNlbGVjdEZpcnN0U2xvdCAoKSB7CiAgICAgIGNvbnN0IGZpcnN0Q2h1bmtQb3MgPSB0aGlzLmdldE5lYXJlc3RDaHVua0J5UG9zKDApCiAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihmaXJzdENodW5rUG9zKQogICAgfSwKCiAgICB0b05leHRTbG90ICgpIHsKICAgICAgaWYgKCF0aGlzLmlucHV0SXNFbXB0eSAmJiB0aGlzLnRva2VuQ2h1bmtzUG9zICYmIHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoKSB7CiAgICAgICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgICAgaWYgKCFjdXJyZW50Q2h1bmspIHsgcmV0dXJuIH0KICAgICAgICBjb25zdCBsYXN0Q2h1bmsgPSB0aGlzLnRva2VuQ2h1bmtzUG9zW3RoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoIC0gMV0KICAgICAgICBpZiAoY3VycmVudENodW5rLnRva2VuICE9PSBsYXN0Q2h1bmsudG9rZW4pIHsKICAgICAgICAgIHRoaXMudG9MYXRlcmFsVG9rZW4oZmFsc2UpCiAgICAgICAgfQogICAgICB9CiAgICB9LAoKICAgIHRvTGF0ZXJhbFRva2VuICh0b0xlZnQpIHsKICAgICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgIGlmICghY3VycmVudENodW5rKSB7CiAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFZhbGlkVmFsdWUoKQogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGNvbnN0IGN1cnJlbnRDaHVua0luZGV4ID0gdGhpcy50b2tlbkNodW5rc1Bvcy5maW5kSW5kZXgoY2hrID0+IGNoay50b2tlbiA9PT0gY3VycmVudENodW5rLnRva2VuKQogICAgICBpZiAoKCF0b0xlZnQgJiYgY3VycmVudENodW5rSW5kZXggPj0gdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGggLSAxKSB8fCAodG9MZWZ0ICYmIGN1cnJlbnRDaHVua0luZGV4ID09PSAwKSkgewogICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgaWYgKHRvTGVmdCkgewogICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSBsZWZ0bW9zdCBzbG90IGFscmVhZHknKQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnWW91XCdyZSBpbiB0aGUgcmlnaHRtb3N0IHNsb3QgYWxyZWFkeScpCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGNvbnN0IHRhcmdldFNsb3RQb3MgPSB0b0xlZnQgPyB0aGlzLnRva2VuQ2h1bmtzUG9zW2N1cnJlbnRDaHVua0luZGV4IC0gMV0gOiB0aGlzLnRva2VuQ2h1bmtzUG9zW2N1cnJlbnRDaHVua0luZGV4ICsgMV0KICAgICAgdGhpcy5kZWJvdW5jZVNldElucHV0U2VsZWN0aW9uKHRhcmdldFNsb3RQb3MpCiAgICB9LAoKICAgIGlzQ3VzdG9tQXBtVGV4dCAoaW5wdXREYXRhKSB7CiAgICAgIGlmICghaW5wdXREYXRhIHx8ICFpbnB1dERhdGEubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9CiAgICAgIGlmICh0aGlzLmFtVGV4dCAmJiB0aGlzLmFtVGV4dCA9PT0gaW5wdXREYXRhKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gJ0FNJyA6ICdhbScKICAgICAgfQogICAgICBpZiAodGhpcy5wbVRleHQgJiYgdGhpcy5wbVRleHQgPT09IGlucHV0RGF0YSkgewogICAgICAgIHJldHVybiB0aGlzLmFwbVR5cGUgPT09ICdBJyA/ICdQTScgOiAncG0nCiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlCiAgICB9LAoKICAgIHJlcGxhY2VDdXN0b21BcG1UZXh0IChpbnB1dFN0cmluZykgewogICAgICBpZiAodGhpcy5hbVRleHQgJiYgdGhpcy5hbVRleHQubGVuZ3RoICYmIGlucHV0U3RyaW5nLmluY2x1ZGVzKHRoaXMuYW1UZXh0KSkgewogICAgICAgIHJldHVybiBpbnB1dFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5hbVRleHQsICdnJyksIHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gJ0FNJyA6ICdhbScpCiAgICAgIH0gZWxzZSBpZiAodGhpcy5wbVRleHQgJiYgdGhpcy5wbVRleHQubGVuZ3RoICYmIGlucHV0U3RyaW5nLmluY2x1ZGVzKHRoaXMucG1UZXh0KSkgewogICAgICAgIHJldHVybiBpbnB1dFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5wbVRleHQsICdnJyksIHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gJ1BNJyA6ICdwbScpCiAgICAgIH0KICAgICAgcmV0dXJuIGlucHV0U3RyaW5nCiAgICB9LAoKICAgIGNoZWNrRHJvcERpcmVjdGlvbiAoKSB7CiAgICAgIGlmICghdGhpcy4kZWwpIHsgcmV0dXJuIH0KICAgICAgbGV0IGNvbnRhaW5lcgogICAgICBpZiAodGhpcy5jb250YWluZXJJZCAmJiB0aGlzLmNvbnRhaW5lcklkLmxlbmd0aCkgewogICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29udGFpbmVySWQpCiAgICAgICAgaWYgKCFjb250YWluZXIgJiYgdGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coYENvbnRhaW5lciB3aXRoIGlkICIke3RoaXMuY29udGFpbmVySWR9IiBub3QgZm91bmQuIEZhbGxiYWNrIHRvIGRvY3VtZW50IGJvZHkuYCkKICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgZWwgPSB0aGlzLiRlbAogICAgICBsZXQgc3BhY2VEb3duCiAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLm9mZnNldEhlaWdodCkgewogICAgICAgIC8vIFZhbGlkIGNvbnRhaW5lciBmb3VuZAogICAgICAgIHNwYWNlRG93biA9IChjb250YWluZXIub2Zmc2V0VG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodCkgLSAoZWwub2Zmc2V0VG9wICsgZWwub2Zmc2V0SGVpZ2h0KQogICAgICB9IGVsc2UgewogICAgICAgIC8vIEZhbGxiYWNrIHRvIGRvY3VtZW50IGJvZHkKICAgICAgICBjb25zdCBkb2NIZWlnaHQgPSBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KQogICAgICAgIHNwYWNlRG93biA9IGRvY0hlaWdodCAtIChlbC5vZmZzZXRUb3AgKyBlbC5vZmZzZXRIZWlnaHQpCiAgICAgIH0KICAgICAgdGhpcy5mb3JjZURyb3BPblRvcCA9IHRoaXMub3B0cy5kcm9wT2Zmc2V0SGVpZ2h0ID4gc3BhY2VEb3duCiAgICB9LAoKICAgIC8vCiAgICAvLyBIZWxwZXJzCiAgICAvLwoKICAgIGlzMTJoUmFuZ2UgKHZhbHVlKSB7CiAgICAgIHJldHVybiAvXlxkezEsMn0oYXxwfEF8UCkkLy50ZXN0KHZhbHVlKQogICAgfSwKCiAgICBtYXRjaDEyaFJhbmdlICh2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWUubWF0Y2goL14oXGR7MSwyfSkoYXxwfEF8UCkkLykKICAgIH0sCgogICAgaXNOdW1iZXIgKHZhbHVlKSB7CiAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpICYmIGlzRmluaXRlKHZhbHVlKQogICAgfSwKCiAgICBpc0Jhc2ljVHlwZSAodHlwZSkgewogICAgICByZXR1cm4gQ09ORklHLkJBU0lDX1RZUEVTLmluY2x1ZGVzKHR5cGUpCiAgICB9LAoKICAgIGxvd2VyQ2FzZWRBcG0gKGFwbVZhbHVlKSB7CiAgICAgIHJldHVybiAoYXBtVmFsdWUgfHwgJycpLnRvTG93ZXJDYXNlKCkKICAgIH0sCgogICAgZ2V0VG9rZW5SZWdleCAodG9rZW4pIHsKICAgICAgc3dpdGNoICh0b2tlbikgewogICAgICAgIGNhc2UgJ0hIJzoKICAgICAgICAgIHJldHVybiAnKFswMV1bMC05XXwyWzAtM118SHsyfSknCiAgICAgICAgY2FzZSAnSCc6CiAgICAgICAgICByZXR1cm4gJyhbMC05XXsxfXwxWzAtOV18MlswLTNdfEh7MX0pJwogICAgICAgIGNhc2UgJ2hoJzoKICAgICAgICAgIHJldHVybiAnKDBbMS05XXwxWzAtMl18aHsyfSknCiAgICAgICAgY2FzZSAnaCc6CiAgICAgICAgICByZXR1cm4gJyhbMS05XXsxfXwxWzAtMl18aHsxfSknCiAgICAgICAgY2FzZSAna2snOgogICAgICAgICAgcmV0dXJuICcoMFsxLTldfDFbMC05XXwyWzAtNF18a3syfSknCiAgICAgICAgY2FzZSAnayc6CiAgICAgICAgICByZXR1cm4gJyhbMS05XXsxfXwxWzAtOV18MlswLTRdfGt7MX0pJwogICAgICAgIGNhc2UgJ21tJzoKICAgICAgICAgIHJldHVybiAnKFswLTVdWzAtOV18bXsyfSknCiAgICAgICAgY2FzZSAnc3MnOgogICAgICAgICAgcmV0dXJuICcoWzAtNV1bMC05XXxzezJ9KScKICAgICAgICBjYXNlICdtJzoKICAgICAgICAgIHJldHVybiAnKFswLTldezF9fFsxLTVdWzAtOV18bXsxfSknCiAgICAgICAgY2FzZSAncyc6CiAgICAgICAgICByZXR1cm4gJyhbMC05XXsxfXxbMS01XVswLTldfHN7MX0pJwogICAgICAgIGNhc2UgJ0EnOgogICAgICAgICAgcmV0dXJuICcoQU18UE18QXsxfSknCiAgICAgICAgY2FzZSAnYSc6CiAgICAgICAgICByZXR1cm4gJyhhbXxwbXxhezF9KScKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuICcnCiAgICAgIH0KICAgIH0sCgogICAgaXNFbXB0eVZhbHVlICh0YXJnZXRUb2tlbiwgdGVzdFZhbHVlKSB7CiAgICAgIHJldHVybiAoIXRlc3RWYWx1ZSB8fCAhdGVzdFZhbHVlLmxlbmd0aCkgfHwgKHRlc3RWYWx1ZSAmJiB0ZXN0VmFsdWUgPT09IHRhcmdldFRva2VuKQogICAgfSwKCiAgICBpc1ZhbGlkVmFsdWUgKHRhcmdldFRva2VuLCB0ZXN0VmFsdWUpIHsKICAgICAgaWYgKCF0YXJnZXRUb2tlbiB8fCB0aGlzLmlzRW1wdHlWYWx1ZSh0YXJnZXRUb2tlbiwgdGVzdFZhbHVlKSkgeyByZXR1cm4gZmFsc2UgfQogICAgICBjb25zdCB0b2tlblJlZ2V4U3RyID0gdGhpcy5nZXRUb2tlblJlZ2V4KHRhcmdldFRva2VuKQogICAgICBpZiAoIXRva2VuUmVnZXhTdHIgfHwgIXRva2VuUmVnZXhTdHIubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9CiAgICAgIHJldHVybiAobmV3IFJlZ0V4cChgXiR7dG9rZW5SZWdleFN0cn0kYCkpLnRlc3QodGVzdFZhbHVlKQogICAgfSwKCiAgICBzYW5pdGl6ZWRWYWx1ZSAodGFyZ2V0VG9rZW4sIGlucHV0VmFsdWUpIHsKICAgICAgaWYgKHRoaXMuaXNWYWxpZFZhbHVlKHRhcmdldFRva2VuLCBpbnB1dFZhbHVlKSkgewogICAgICAgIHJldHVybiBpbnB1dFZhbHVlCiAgICAgIH0KICAgICAgcmV0dXJuICcnCiAgICB9LAoKICAgIGdldFRva2VuVHlwZSAodG9rZW4pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5Vc2UudHlwZXNbdGhpcy5pblVzZS50b2tlbnMuaW5kZXhPZih0b2tlbildIHx8ICcnCiAgICB9LAoKICAgIGdldFRva2VuQnlUeXBlICh0eXBlKSB7CiAgICAgIHJldHVybiB0aGlzW2Ake3R5cGV9VHlwZWBdIHx8ICcnCiAgICB9LAoKICAgIGlzTWludXRlT3JTZWNvbmQgKHR5cGUpIHsKICAgICAgcmV0dXJuIFsnbWludXRlJywgJ3NlY29uZCddLmluY2x1ZGVzKHR5cGUpCiAgICB9LAoKICAgIGRlYnVnTG9nIChsb2dUZXh0KSB7CiAgICAgIGlmICghbG9nVGV4dCB8fCAhbG9nVGV4dC5sZW5ndGgpIHsgcmV0dXJuIH0KICAgICAgbGV0IGlkZW50aWZpZXIgPSAnJwogICAgICBpZiAodGhpcy5pZCkgewogICAgICAgIGlkZW50aWZpZXIgKz0gYCMke3RoaXMuaWR9YAogICAgICB9CiAgICAgIGlmICh0aGlzLm5hbWUpIHsKICAgICAgICBpZGVudGlmaWVyICs9IGBbbmFtZT0ke3RoaXMubmFtZX1dYAogICAgICB9CiAgICAgIGlmICh0aGlzLmlucHV0Q2xhc3MpIHsKICAgICAgICBsZXQgaW5wdXRDbGFzc2VzID0gW10KICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5wdXRDbGFzcyA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIGlucHV0Q2xhc3NlcyA9IHRoaXMuaW5wdXRDbGFzcy5zcGxpdCgvXHMvZykKICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5pbnB1dENsYXNzKSkgewogICAgICAgICAgaW5wdXRDbGFzc2VzID0gW10uY29uY2F0KFtdLCB0aGlzLmlucHV0Q2xhc3MpCiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5pbnB1dENsYXNzID09PSAnb2JqZWN0JykgewogICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnB1dENsYXNzKS5mb3JFYWNoKGNsc05hbWUgPT4gewogICAgICAgICAgICBpZiAodGhpcy5pbnB1dENsYXNzW2Nsc05hbWVdKSB7CiAgICAgICAgICAgICAgaW5wdXRDbGFzc2VzLnB1c2goY2xzTmFtZSkKICAgICAgICAgICAgfQogICAgICAgICAgfSkKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaW5wdXRDbGFzcyBvZiBpbnB1dENsYXNzZXMpIHsKICAgICAgICAgIGlmIChpbnB1dENsYXNzICYmIGlucHV0Q2xhc3MudHJpbSgpLmxlbmd0aCkgewogICAgICAgICAgICBpZGVudGlmaWVyICs9IGAuJHtpbnB1dENsYXNzLnRyaW0oKX1gCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGZpbmFsTG9nVGV4dCA9IGBERUJVRzogJHtsb2dUZXh0fSR7aWRlbnRpZmllciA/IGBcblx0KCR7aWRlbnRpZmllcn0pYCA6ICcnIH1gCiAgICAgIGlmICh3aW5kb3cuY29uc29sZS5kZWJ1ZyAmJiB0eXBlb2Ygd2luZG93LmNvbnNvbGUuZGVidWcgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICB3aW5kb3cuY29uc29sZS5kZWJ1ZyhmaW5hbExvZ1RleHQpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGZpbmFsTG9nVGV4dCkKICAgICAgfQogICAgfQogIH0sCgogIG1vdW50ZWQgKCkgewogICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogICAgdGhpcy5yZW5kZXJGb3JtYXQoKQogIH0sCgogIGJlZm9yZURlc3Ryb3kgKCkgewogICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogIH0KfQo="},{"version":3,"sources":["vue-timepicker.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"vue-timepicker.vue","sourceRoot":"node_modules/vue2-timepicker/src","sourcesContent":["<script>\nconst CONFIG = {\n  HOUR_TOKENS: ['HH', 'H', 'hh', 'h', 'kk', 'k'],\n  MINUTE_TOKENS: ['mm', 'm'],\n  SECOND_TOKENS: ['ss', 's'],\n  APM_TOKENS: ['A', 'a'],\n  BASIC_TYPES: ['hour', 'minute', 'second', 'apm']\n}\n\nconst DEFAULT_OPTIONS = {\n  format: 'HH:mm',\n  minuteInterval: 1,\n  secondInterval: 1,\n  hourRange: null,\n  minuteRange: null,\n  secondRange: null,\n  hideDisabledHours: false,\n  hideDisabledMinutes: false,\n  hideDisabledSeconds: false,\n  hideDisabledItems: false,\n  hideDropdown: false,\n  blurDelay: 300,\n  manualInputTimeout: 1000,\n  dropOffsetHeight: 160\n}\n\nexport default {\n  name: 'VueTimepicker',\n  props: {\n    value: { type: [ Object, String ] },\n    format: { type: String },\n    minuteInterval: { type: [ Number, String ] },\n    secondInterval: { type: [ Number, String ] },\n\n    hourRange: { type: Array },\n    minuteRange: { type: Array },\n    secondRange: { type: Array },\n\n    hideDisabledHours: { type: Boolean, default: false },\n    hideDisabledMinutes: { type: Boolean, default: false },\n    hideDisabledSeconds: { type: Boolean, default: false },\n    hideDisabledItems: { type: Boolean, default: false },\n\n    hideClearButton: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    closeOnComplete: { type: Boolean, default: false },\n\n    id: { type: String },\n    name: { type: String },\n    inputClass: { type: [ String, Object, Array ] },\n    placeholder: { type: String },\n    tabindex: { type: [ Number, String ], default: 0 },\n    inputWidth: { type: String },\n    autocomplete: { type: String, default: 'off' },\n\n    hourLabel: { type: String },\n    minuteLabel: { type: String },\n    secondLabel: { type: String },\n    apmLabel: { type: String },\n    amText: { type: String },\n    pmText: { type: String },\n\n    blurDelay: { type: [ Number, String ] },\n    advancedKeyboard: { type: Boolean, default: false },\n\n    lazy: { type: Boolean, default: false },\n    autoScroll: { type: Boolean, default: false },\n\n    dropDirection: { type: String, default: 'down' },\n    dropOffsetHeight: { type: [ Number, String ] },\n    containerId: { type: String },\n    appendToBody: { type: Boolean, default: false },\n\n    manualInput: { type: Boolean, default: false },\n    manualInputTimeout: { type: [ Number, String ] },\n    hideDropdown: { type: Boolean, default: false },\n    fixedDropdownButton: { type: Boolean, default: false },\n\n    debugMode: { type: Boolean, default: false }\n  },\n\n  data () {\n    return {\n      timeValue: {},\n\n      hours: [],\n      minutes: [],\n      seconds: [],\n      apms: [],\n\n      isActive: false,\n      showDropdown: false,\n      isFocusing: false,\n      debounceTimer: undefined,\n\n      hourType: 'HH',\n      minuteType: 'mm',\n      secondType: '',\n      apmType: '',\n      hour: '',\n      minute: '',\n      second: '',\n      apm: '',\n      fullValues: undefined,\n      bakDisplayTime: undefined,\n      doClearApmChecking: false,\n\n      selectionTimer: undefined,\n      kbInputTimer: undefined,\n      kbInputLog: '',\n      bakCurrentPos: undefined,\n      forceDropOnTop: false\n    }\n  },\n\n  computed: {\n    opts () {\n      const options = Object.assign({}, DEFAULT_OPTIONS)\n\n      if (this.format && this.format.length) {\n        options.format = String(this.format)\n      }\n\n      if (this.isNumber(this.minuteInterval)) {\n        options.minuteInterval = +this.minuteInterval\n      }\n      // minuteInterval failsafe\n      if (!options.minuteInterval || options.minuteInterval < 1 || options.minuteInterval > 60) {\n        if (this.debugMode) {\n          if (options.minuteInterval > 60) {\n            this.debugLog(`\"minute-interval\" should be less than 60. Current value is ${this.minuteInterval}`)\n          } else if (options.minuteInterval === 0 || options.minuteInterval < 1) {\n            this.debugLog(`\"minute-interval\" should be NO less than 1. Current value is ${this.minuteInterval}`)\n          }\n        }\n        if (options.minuteInterval === 0) {\n          options.minuteInterval = 60\n        } else {\n          options.minuteInterval = 1\n        }\n      }\n\n      if (this.isNumber(this.secondInterval)) {\n        options.secondInterval = +this.secondInterval\n      }\n      // secondInterval failsafe\n      if (!options.secondInterval || options.secondInterval < 1 || options.secondInterval > 60) {\n        if (this.debugMode) {\n          if (options.secondInterval > 60) {\n            this.debugLog(`\"second-interval\" should be less than 60. Current value is ${this.secondInterval}`)\n          } else if (options.secondInterval === 0 || options.secondInterval < 1) {\n            this.debugLog(`\"second-interval\" should be NO less than 1. Current value is ${this.secondInterval}`)\n          }\n        }\n        if (options.secondInterval === 0) {\n          options.secondInterval = 60\n        } else {\n          options.secondInterval = 1\n        }\n      }\n\n      if (this.hourRange && Array.isArray(this.hourRange)) {\n        options.hourRange = JSON.parse(JSON.stringify(this.hourRange))\n        if (!this.hourRange.length && this.debugMode) {\n          this.debugLog('The \"hour-range\" array is empty (length === 0)')\n        }\n      }\n\n      if (this.minuteRange && Array.isArray(this.minuteRange)) {\n        options.minuteRange = JSON.parse(JSON.stringify(this.minuteRange))\n        if (!this.minuteRange.length && this.debugMode) {\n          this.debugLog('The \"minute-range\" array is empty (length === 0)')\n        }\n      }\n\n      if (this.secondRange && Array.isArray(this.secondRange)) {\n        options.secondRange = JSON.parse(JSON.stringify(this.secondRange))\n        if (!this.secondRange.length && this.debugMode) {\n          this.debugLog('The \"second-range\" array is empty (length === 0)')\n        }\n      }\n\n      if (this.hideDisabledItems) {\n        options.hideDisabledItems = true\n      }\n\n      if (this.hideDisabledHours || this.hideDisabledItems) {\n        options.hideDisabledHours = true\n      }\n      if (this.hideDisabledMinutes || this.hideDisabledItems) {\n        options.hideDisabledMinutes = true\n      }\n      if (this.hideDisabledSeconds || this.hideDisabledItems) {\n        options.hideDisabledSeconds = true\n      }\n\n      if (this.hideDropdown) {\n        if (this.manualInput) {\n          options.hideDropdown = true\n        } else if (this.debugMode) {\n          this.debugLog('\"hide-dropdown\" only works with \"manual-input\" mode')\n        }\n      }\n\n      if (this.blurDelay && +this.blurDelay > 0) {\n        options.blurDelay = +this.blurDelay\n      }\n\n      if (this.manualInputTimeout && +this.manualInputTimeout > 0) {\n        options.manualInputTimeout = +this.manualInputTimeout\n      }\n\n      if (this.dropOffsetHeight && +this.dropOffsetHeight > 0) {\n        options.dropOffsetHeight = +this.dropOffsetHeight\n      }\n\n      return options\n    },\n\n    useStringValue () {\n      return typeof this.value === 'string'\n    },\n\n    formatString () {\n      return this.opts.format || DEFAULT_OPTIONS.format\n    },\n\n    inUse () {\n      const typesInUse = CONFIG.BASIC_TYPES.filter(type => this.getTokenByType(type))\n      // Sort types and tokens by their sequence in the \"format\" string\n      typesInUse.sort((l, r) => {\n        return this.formatString.indexOf(this.getTokenByType(l) || null) - this.formatString.indexOf(this.getTokenByType(r) || null)\n      })\n      const tokensInUse = typesInUse.map(type => this.getTokenByType(type))\n      return {\n        hour: !!this.hourType,\n        minute: !!this.minuteType,\n        second: !!this.secondType,\n        apm: !!this.apmType,\n        types: typesInUse || [],\n        tokens: tokensInUse || []\n      }\n    },\n\n    displayTime () {\n      let formatString = String(this.formatString)\n      if (this.hour) {\n        formatString = formatString.replace(new RegExp(this.hourType, 'g'), this.hour)\n      }\n      if (this.minute) {\n        formatString = formatString.replace(new RegExp(this.minuteType, 'g'), this.minute)\n      }\n      if (this.second && this.secondType) {\n        formatString = formatString.replace(new RegExp(this.secondType, 'g'), this.second)\n      }\n      if (this.apm && this.apmType) {\n        formatString = formatString.replace(new RegExp(this.apmType, 'g'), this.apm)\n      }\n      return formatString\n    },\n\n    customDisplayTime () {\n      if (!this.amText && !this.pmText) {\n        return this.displayTime\n      }\n      return this.displayTime.replace(new RegExp(this.apm, 'g'), this.apmDisplayText(this.apm))\n    },\n\n    inputIsEmpty () {\n      return this.formatString === this.displayTime\n    },\n\n    allValueSelected () {\n      if (\n        (this.inUse.hour && !this.hour) ||\n        (this.inUse.minute && !this.minute) ||\n        (this.inUse.second && !this.second) ||\n        (this.inUse.apm && !this.apm)\n      ) {\n        return false\n      }\n      return true\n    },\n\n    columnsSequence () {\n      return this.inUse.types.map(type => type) || []\n    },\n\n    showClearBtn () {\n      if (this.hideClearButton || this.disabled) {\n        return false\n      }\n      return !this.inputIsEmpty\n    },\n\n    showDropdownBtn () {\n      if (this.fixedDropdownButton) { return true }\n      if (this.opts.hideDropdown && this.isActive && !this.showDropdown) {\n        return true\n      }\n      return false\n    },\n\n    baseOn12Hours () {\n      return this.hourType === 'h' || this.hourType === 'hh'\n    },\n\n    hourRangeIn24HrFormat () {\n      if (!this.hourType || !this.opts.hourRange) { return false }\n      if (!this.opts.hourRange.length) { return [] }\n\n      const range = []\n      this.opts.hourRange.forEach(value => {\n        if (value instanceof Array) {\n          if (value.length > 2 && this.debugMode) {\n            this.debugLog(`Nested array within \"hour-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n          }\n\n          let start = value[0]\n          let end = value[1] || value[0]\n\n          if (this.is12hRange(start)) {\n            start = this.translate12hRange(start)\n          }\n          if (this.is12hRange(end)) {\n            end = this.translate12hRange(end)\n          }\n\n          for (let i = +start; i <= +end; i++) {\n            if (i < 0 || i > 24) { continue }\n            if (!range.includes(i)) {\n              range.push(i)\n            }\n          }\n        } else {\n          if (this.is12hRange(value)) {\n            value = this.translate12hRange(value)\n          } else {\n            value = +value\n          }\n          if (value < 0 || value > 24) { return }\n          if (!range.includes(value)) {\n            range.push(value)\n          }\n        }\n      })\n      range.sort((l, r) => { return l - r })\n      return range\n    },\n\n    restrictedHourRange () {\n      // No restriction\n      if (!this.hourRangeIn24HrFormat) { return false }\n      // 12-Hour\n      if (this.baseOn12Hours) {\n        const range = this.hourRangeIn24HrFormat.map((value) => {\n          if (value === 12) {\n            return '12p'\n          } else if (value === 24 || value === 0) {\n            return '12a'\n          }\n          return value > 12 ? `${value % 12}p` : `${value}a`\n        })\n        return range\n      }\n      // 24-Hour\n      return this.hourRangeIn24HrFormat\n    },\n\n    validHoursList () {\n      if (!this.manualInput) { return false }\n      if (this.restrictedHourRange) {\n        let list = []\n        if (this.baseOn12Hours) {\n          list = this.restrictedHourRange.map(hr => {\n            const l = hr.substr(0, hr.length - 1)\n            const r = hr.substr(-1)\n            return `${this.formatValue(this.hourType, l)}${r}`\n          })\n          const am12Index = list.indexOf('12a')\n          if (am12Index > 0) {\n            // Make '12a' the first item in h/hh\n            list.unshift(list.splice(am12Index, 1)[0])\n          }\n          return list\n        }\n        list = this.restrictedHourRange.map(hr => {\n          return this.formatValue(this.hourType, hr)\n        })\n        if (list.length > 1 && list[0] && list[0] === '24') {\n          // Make '24' the last item in k/kk\n          list.push(list.shift())\n        }\n        return list\n      }\n      if (this.baseOn12Hours) {\n        return [].concat([], this.hours.map(hr => `${hr}a`), this.hours.map(hr => `${hr}p`))\n      }\n      return this.hours\n    },\n\n    has () {\n      const result = {\n        customApmText: false\n      }\n      const apmEnabled = !!this.apmType\n\n      if (apmEnabled && this.hourRangeIn24HrFormat && this.hourRangeIn24HrFormat.length) {\n        const range = [].concat([], this.hourRangeIn24HrFormat)\n        result.am = range.some(value => value < 12 || value === 24)\n        result.pm = range.some(value => value >= 12 && value < 24)\n      } else {\n        result.am = apmEnabled\n        result.pm = apmEnabled\n      }\n      if ((this.amText && this.amText.length) || (this.pmText && this.pmText.length)) {\n        result.customApmText = true\n      }\n      return result\n    },\n\n    minuteRangeList () {\n      if (!this.minuteType || !this.opts.minuteRange) { return false }\n      if (!this.opts.minuteRange.length) { return [] }\n      return this.renderRangeList(this.opts.minuteRange, 'minute')\n    },\n\n    secondRangeList () {\n      if (!this.secondType || !this.opts.secondRange) { return false }\n      if (!this.opts.secondRange.length) { return [] }\n      return this.renderRangeList(this.opts.secondRange, 'second')\n    },\n    \n    hourLabelText () {\n      return this.hourLabel || this.hourType\n    },\n    minuteLabelText () {\n      return this.minuteLabel || this.minuteType\n    },\n    secondLabelText() {\n      return this.secondLabel || this.secondType\n    },\n    apmLabelText () {\n      return this.apmLabel || this.apmType\n    },\n\n    inputWidthStyle () {\n      if (!this.inputWidth || !this.inputWidth.length) { return }\n      return {\n        width: this.inputWidth\n      }\n    },\n\n    tokenRegexBase () {\n      return this.inUse.tokens.join('|')\n    },\n\n    tokenChunks () {\n      if (!this.manualInput && !this.useStringValue) { return false }\n\n      const formatString = String(this.formatString)\n      const tokensRegxStr = `(${this.tokenRegexBase})+?`\n      const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n\n      const tokenChunks = []\n      for (let tkMatch of tokensMatchAll) {\n        const rawToken = tkMatch[0]\n        const tokenMatchItem = {\n          index: tkMatch.index,\n          token: rawToken,\n          type: this.getTokenType(rawToken),\n          needsCalibrate: rawToken.length < 2,\n          len: (rawToken || '').length\n        }\n        tokenChunks.push(tokenMatchItem)\n      }\n      return tokenChunks\n    },\n\n    needsPosCalibrate () {\n      if (!this.manualInput) { return false }\n      return this.tokenChunks.some(chk => chk.needsCalibrate)\n    },\n\n    tokenChunksPos () {\n      if (!this.manualInput) { return false }\n      if (!this.needsPosCalibrate) {\n        return this.tokenChunks.map(chk => {\n          return {\n            token: chk.token,\n            type: chk.type,\n            start: chk.index,\n            end: chk.index + chk.len\n          }\n        })\n      }\n      const list = []\n      let calibrateLen = 0\n      this.tokenChunks.forEach(chk => {\n        let chunkCurrentLen\n        // Adjust for customized AM/PM text\n        if (chk.type === 'apm' && this.has.customApmText) {\n          if (this.apm && this.apm.length) {\n            const customApmText = this.apm.toLowerCase() === 'am' ? this.amText : this.pmText\n            chunkCurrentLen = (customApmText && customApmText.length) ? customApmText.length : chk.len\n          } else {\n            chunkCurrentLen = chk.len\n          }\n        // Others\n        } else {\n          chunkCurrentLen = this[chk.type] && this[chk.type].length ? this[chk.type].length : chk.len\n        }\n        list.push({\n          token: chk.token,\n          type: chk.type,\n          start: chk.index + calibrateLen,\n          end: chk.index + calibrateLen + chunkCurrentLen\n        })\n        if (chk.needsCalibrate && chunkCurrentLen > chk.len) {\n          calibrateLen += (chunkCurrentLen - chk.len)\n        }\n      })\n      return list\n    },\n\n    invalidValues () {\n      if (this.inputIsEmpty) { return [] }\n      if (!this.restrictedHourRange && !this.minuteRangeList && !this.secondRangeList && this.opts.minuteInterval === 1 && this.opts.secondInterval === 1) { return [] }\n\n      const result = []\n      if (this.inUse.hour && !this.isEmptyValue(this.hourType, this.hour) && (!this.isValidValue(this.hourType, this.hour) || this.isDisabled('hour', this.hour))) {\n        result.push('hour')\n      }\n      if (this.inUse.minute && !this.isEmptyValue(this.minuteType, this.minute) && (!this.isValidValue(this.minuteType, this.minute) || this.isDisabled('minute', this.minute) || this.notInInterval('minute', this.minute))) {\n        result.push('minute')\n      }\n      if (this.inUse.second && !this.isEmptyValue(this.secondType, this.second) && (!this.isValidValue(this.secondType, this.second) || this.isDisabled('second', this.second) || this.notInInterval('second', this.second))) {\n        result.push('second')\n      }\n      if (this.inUse.apm && !this.isEmptyValue(this.apmType, this.apm) && (!this.isValidValue(this.apmType, this.apm) || this.isDisabled('apm', this.apm))) {\n        result.push('apm')\n      }\n      if (result.length) {\n        return result\n      }\n      return []\n    },\n\n    hasInvalidInput () {\n      return Boolean(this.invalidValues && this.invalidValues.length)\n    },\n\n    autoDirectionEnabled () {\n      return this.dropDirection === 'auto'\n    },\n\n    dropdownDirClass () {\n      if (this.autoDirectionEnabled) {\n        return this.forceDropOnTop ? 'drop-up' : 'drop-down'\n      }\n      return this.dropDirection === 'up' ? 'drop-up' : 'drop-down'      \n    }\n  },\n\n  watch: {\n    'opts.format' (newValue) {\n      this.renderFormat(newValue)\n    },\n    'opts.minuteInterval' (newInteval) {\n      this.renderList('minute', newInteval)\n    },\n    'opts.secondInterval' (newInteval) {\n      this.renderList('second', newInteval)\n    },\n    value: {\n      deep: true,\n      handler () {\n        this.readValues()\n      }\n    },\n    displayTime () {\n      this.fillValues()\n    },\n    disabled (toDisabled) {\n      if (toDisabled) {\n        // Force close dropdown and reset status when disabled\n        if (this.isActive) {\n          this.isActive = false\n        }\n        if (this.showDropdown) {\n          this.showDropdown = false\n        }\n      }\n    },\n    'invalidValues.length' (newLength, oldLength) {\n      if (newLength && newLength >= 1) {\n        this.$emit('error', this.invalidValues)\n      } else if (oldLength && oldLength >= 1) {\n        this.$emit('error', [])\n      }\n    }\n  },\n\n  methods: {\n    formatValue (token, i) {\n      if (!this.isNumber(i)) { return '' }\n      i = +i\n      switch (token) {\n        case 'H':\n        case 'h':\n        case 'k':\n        case 'm':\n        case 's':\n          if (['h', 'k'].includes(token) && i === 0) {\n            return token === 'k' ? '24' : '12'\n          }\n          return String(i)\n        case 'HH':\n        case 'mm':\n        case 'ss':\n        case 'hh':\n        case 'kk':\n          if (['hh', 'kk'].includes(token) && i === 0) {\n            return token === 'kk' ? '24' : '12'\n          }\n          return i < 10 ? `0${i}` : String(i)\n        default:\n          return ''\n      }\n    },\n\n    checkAcceptingType (validValues, formatString) {\n      if (!validValues || !formatString || !formatString.length) { return '' }\n      for (let i = 0; i < validValues.length; i++) {\n        if (formatString.indexOf(validValues[i]) > -1) {\n          return validValues[i]\n        }\n      }\n      return ''\n    },\n\n    renderFormat (newFormat) {\n      newFormat = newFormat || this.opts.format || DEFAULT_OPTIONS.format\n\n      let hourType = this.checkAcceptingType(CONFIG.HOUR_TOKENS, newFormat)\n      let minuteType = this.checkAcceptingType(CONFIG.MINUTE_TOKENS, newFormat)\n      this.secondType = this.checkAcceptingType(CONFIG.SECOND_TOKENS, newFormat)\n      this.apmType = this.checkAcceptingType(CONFIG.APM_TOKENS, newFormat)\n\n      // Failsafe checking\n      if (!hourType && !minuteType && !this.secondType && !this.apmType) {\n        if (this.debugMode && this.format) {\n          this.debugLog(`No valid tokens found in your defined \"format\" string \"${this.format}\". Fallback to the default \"HH:mm\" format.`)\n        }\n        hourType = 'HH'\n        minuteType = 'mm'\n      }\n      this.hourType = hourType\n      this.minuteType = minuteType\n\n      this.hourType ? this.renderHoursList() : this.hours = []\n      this.minuteType ? this.renderList('minute') : this.minutes = []\n      this.secondType ? this.renderList('second') : this.seconds = []\n      this.apmType ? this.renderApmList() : this.apms = []\n\n      this.$nextTick(() => {\n        this.readValues()\n      })\n    },\n\n    renderHoursList () {\n      const hoursCount = this.baseOn12Hours ? 12 : 24\n      const hours = []\n      for (let i = 0; i < hoursCount; i++) {\n        if (this.hourType === 'k' || this.hourType === 'kk') {\n          hours.push(this.formatValue(this.hourType, i + 1))\n        } else {\n          hours.push(this.formatValue(this.hourType, i))\n        }\n      }\n      this.hours = hours\n    },\n\n    renderList (listType, interval) {\n      if (!this.isMinuteOrSecond(listType)) { return }\n\n      const isMinute = listType === 'minute'\n      interval = interval || (isMinute ? (this.opts.minuteInterval || DEFAULT_OPTIONS.minuteInterval) : (this.opts.secondInterval || DEFAULT_OPTIONS.secondInterval))\n\n      const result = []\n      for (let i = 0; i < 60; i += interval) {\n        result.push(this.formatValue(isMinute ? this.minuteType : this.secondType, i))\n      }\n      isMinute ? this.minutes = result : this.seconds = result\n    },\n\n    renderApmList () {\n      this.apms = this.apmType === 'A' ? ['AM', 'PM'] : ['am', 'pm']\n    },\n\n    readValues () {\n      if (this.useStringValue) {\n        if (this.debugMode) {\n          this.debugLog(`Received a string value: \"${this.value}\"`)\n        }\n        this.readStringValues(this.value)\n      } else {\n        if (this.debugMode) {\n          this.debugLog(`Received an object value: \"${JSON.stringify(this.value || {})}\"`)\n        }\n        this.readObjectValues(this.value)\n      }\n    },\n\n    readObjectValues (objValue) {\n      const timeValue = JSON.parse(JSON.stringify(objValue || {}))\n      const values = Object.keys(timeValue)\n\n      // Failsafe for empty `v-model` object\n      if (values.length === 0) {\n        this.addFallbackValues()\n        return\n      }\n\n      CONFIG.BASIC_TYPES.forEach(type => {\n        const token = this.getTokenByType(type)\n        if (values.indexOf(token) > -1) {\n          const sanitizedValue = this.sanitizedValue(token, timeValue[token])\n          this[type] = sanitizedValue\n          timeValue[token] = sanitizedValue\n        } else {\n          this[type] = ''\n        }\n      })\n      this.timeValue = timeValue\n    },\n\n    getMatchAllByRegex (testString, regexString) {\n      const str = 'polyfillTest'\n      const needsPolyfill = Boolean(!str.matchAll || typeof str.matchAll !== 'function')\n      return needsPolyfill ? this.polyfillMatchAll(testString, regexString) : testString.matchAll(new RegExp(regexString, 'g'))\n    },\n\n    readStringValues (stringValue) {\n      // Failsafe for empty `v-model` string\n      if (!stringValue || !stringValue.length) {\n        this.addFallbackValues()\n        return\n      }\n\n      const formatString = String(this.formatString)\n      const tokensRegxStr = `(${this.tokenRegexBase})+?`\n      const othersRegxStr = `[^(${this.tokenRegexBase})]+`\n\n      const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n      const othersMatchAll = this.getMatchAllByRegex(formatString, othersRegxStr)\n\n      const chunks = []\n      const tokenChunks = []\n\n      for (let tkMatch of tokensMatchAll) {\n        const tokenMatchItem = {\n          index: tkMatch.index,\n          token: tkMatch[0],\n          isValueToken: true\n        }\n        chunks.push(tokenMatchItem)\n        tokenChunks.push(tokenMatchItem)\n      }\n\n      for (let otMatch of othersMatchAll) {\n        chunks.push({\n          index: otMatch.index,\n          token: otMatch[0]\n        })\n      }\n\n      chunks.sort((l, r) => l.index < r.index ? -1 : 1)\n\n      let regexCombo = ''\n      chunks.forEach(chunk => {\n        if (chunk.isValueToken) {\n          const tokenRegex = this.getTokenRegex(chunk.token) || ''\n          regexCombo += tokenRegex\n        } else {\n          const safeChars = chunk.token.replace(/\\\\{0}(\\*|\\?|\\.|\\+)/g, '\\\\$1')\n          regexCombo += `(?:${safeChars})`\n        }\n      })\n\n      const comboReg = new RegExp(regexCombo)\n\n      // Do test before match\n      if (comboReg.test(stringValue)) {\n        const matchResults = stringValue.match(new RegExp(regexCombo))\n        const valueResults = matchResults.slice(1, tokenChunks.length + 1)\n        const timeValue = {}\n        valueResults.forEach((value, vrIndex) => {\n          if (tokenChunks[vrIndex]) {\n            const targetToken = tokenChunks[vrIndex].token\n            timeValue[targetToken] = this.setValueFromString(value, targetToken)\n          }\n        })\n        this.timeValue = timeValue\n\n        if (this.debugMode) {\n          const tokenChunksForLog = tokenChunks.map(tChunk => tChunk && tChunk.token)\n          this.debugLog(`Successfully parsed values ${JSON.stringify(valueResults)}\\nfor ${JSON.stringify(tokenChunksForLog)}\\nin format pattern '${this.formatString}'`)\n        }\n      } else {\n        if (this.debugMode) {\n          this.debugLog(`The input string in \"v-model\" does NOT match the \"format\" pattern\\nformat: ${this.formatString}\\nv-model: ${stringValue}`)\n        }\n      }\n    },\n\n    polyfillMatchAll (targetString, regxStr) {\n      const matchesList = targetString.match(new RegExp(regxStr, 'g'))\n      const result = []\n      const indicesReg = []\n      if (matchesList && matchesList.length) {\n        matchesList.forEach(matchedItem => {\n          const existIndex = indicesReg.findIndex(idxItem => idxItem.str === matchedItem)\n          let index\n          if (existIndex >= 0) {\n            if (indicesReg[existIndex] && indicesReg[existIndex].regex) {\n              index = indicesReg[existIndex].regex.exec(targetString).index\n            }\n          } else {\n            const itemIndicesRegex = new RegExp(matchedItem, 'g')\n            index = itemIndicesRegex.exec(targetString).index\n            indicesReg.push({\n              str: String(matchedItem),\n              regex: itemIndicesRegex\n            })\n          }\n          result.push({\n            0: String(matchedItem),\n            index: index\n          })\n        })\n      }\n      return result\n    },\n\n    addFallbackValues () {\n      const timeValue = {}\n      this.inUse.types.forEach(type => {\n        timeValue[this.getTokenByType(type)] = ''\n      })\n      this.timeValue = timeValue\n    },\n\n    setValueFromString (parsedValue, token) {\n      if (!token || !parsedValue) { return '' }\n      const tokenType = this.getTokenType(token)\n      if (!tokenType || !tokenType.length) { return '' }\n      const stdValue = (parsedValue !== this.getTokenByType(tokenType)) ? parsedValue : ''\n      this[tokenType] = stdValue\n      return stdValue\n    },\n\n    fillValues (forceEmit) {\n      const fullValues = {}\n\n      const baseHour = this.hour\n      const baseHourType = this.hourType\n\n      let apmValue\n\n      // Hour type or hour value is NOT set in the \"format\" string\n      if (!baseHourType || !this.isNumber(baseHour)) {\n        CONFIG.HOUR_TOKENS.forEach(token => fullValues[token] = '')\n        apmValue = this.lowerCasedApm(this.apm || '')\n        fullValues.a = apmValue\n        fullValues.A = apmValue.toUpperCase()\n\n      // Both Hour type and value are set\n      } else {\n        const hourValue = +baseHour\n        const apmValue = (this.baseOn12Hours && this.apm) ? this.lowerCasedApm(this.apm) : false\n\n        CONFIG.HOUR_TOKENS.forEach((token) => {\n          if (token === baseHourType) {\n            fullValues[token] = baseHour\n            return\n          }\n\n          let value\n          let apm\n          switch (token) {\n            case 'H':\n            case 'HH':\n            case 'k':\n            case 'kk':\n              if (this.baseOn12Hours) {\n                if (apmValue === 'pm') {\n                  value = hourValue < 12 ? hourValue + 12 : hourValue\n                } else if (['k', 'kk'].includes(token)) {\n                  value = hourValue === 12 ? 24 : hourValue\n                } else {\n                  value = hourValue % 12\n                }\n              } else {\n                if (['k', 'kk'].includes(token)) {\n                  value = hourValue === 0 ? 24 : hourValue\n                } else {\n                  value = hourValue % 24\n                }\n              }\n              fullValues[token] = this.formatValue(token, value)\n              break\n            case 'h':\n            case 'hh':\n              // h <-> hh\n              if (this.baseOn12Hours) {\n                value = hourValue\n                apm = apmValue || ''\n              // Read from other hour formats\n              } else {\n                if (hourValue > 11 && hourValue < 24) {\n                  apm = 'pm'\n                  value = hourValue === 12 ? 12 : hourValue % 12\n                } else {\n                  apm = 'am'\n                  value = hourValue % 12 === 0 ? 12 : hourValue\n                }\n              }\n              fullValues[token] = this.formatValue(token, value)\n              fullValues.a = apm\n              fullValues.A = apm.toUpperCase()\n              break\n          }\n        })\n      }\n\n      fullValues.m = this.formatValue('m', this.minute)\n      fullValues.mm = this.formatValue('mm', this.minute)\n      fullValues.s = this.formatValue('s', this.second)\n      fullValues.ss = this.formatValue('ss', this.second)\n\n      this.fullValues = fullValues\n\n      // On lazy mode, emit `input` and `change` events only when:\n      // - The user pick a new value and then close the dropdown\n      // - The user click the (\"x\") clear button\n      if (!this.lazy || forceEmit) {\n        this.emitTimeValue()\n      }\n\n      if (this.closeOnComplete && this.allValueSelected && this.showDropdown) {\n        this.toggleActive()\n      }\n    },\n\n    getFullData () {\n      if (!this.fullValues) {\n        this.fillValues()\n      }\n      return {\n        data: JSON.parse(JSON.stringify(this.fullValues)),\n        displayTime: this.inputIsEmpty ? '' : String(this.displayTime)\n      }\n    },\n\n    emitTimeValue () {\n      if (this.lazy && this.bakDisplayTime === this.displayTime) {\n        if (this.debugMode) {\n          this.debugLog('The value does not change on `lazy` mode. Skip the emitting `input` and `change` event.')\n        }\n        return\n      }\n\n      const fullData = this.getFullData()\n\n      if (this.useStringValue) {\n        this.$emit('input', fullData.displayTime)\n      } else {\n        const fullValues = fullData.data\n        const tokensInUse = this.inUse.tokens || []\n        const timeValue = {}\n        tokensInUse.forEach((token) => {\n          timeValue[token] = fullValues[token] || ''\n        })\n        this.$emit('input', JSON.parse(JSON.stringify(timeValue)))\n      }\n\n      this.$emit('change', fullData)\n    },\n\n    translate12hRange (value) {\n      const valueT = this.match12hRange(value)\n      if (+valueT[1] === 12) {\n        return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 0 : 12)\n      }\n      return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 12 : 0)\n    },\n\n    isDisabled (type, value) {\n      if (!this.isBasicType(type) || !this.inUse[type]) { return true }\n      switch (type) {\n        case 'hour':\n          return this.isDisabledHour(value)\n        case 'minute':\n        case 'second':\n          if (!this[`${type}RangeList`]) {\n            return false\n          }\n          return !this[`${type}RangeList`].includes(value)\n        case 'apm':\n          if (!this.restrictedHourRange) {\n            return false\n          }\n          return !this.has[this.lowerCasedApm(value)]\n        default:\n          return true\n      }\n    },\n\n    isDisabledHour (value) {\n      if (!this.restrictedHourRange) { return false }\n      if (this.baseOn12Hours) {\n        if (!this.apm || !this.apm.length) {\n          return false\n        } else {\n          const token = this.apm.toLowerCase() === 'am' ? 'a' : 'p'\n          return !this.restrictedHourRange.includes(`${+value}${token}`)\n        }\n      }\n      // Fallback for 'HH' and 'H hour format with a `hour-range` in a 12-hour form\n      if (\n        (this.hourType === 'HH' || this.hourType === 'H') &&\n        +value === 0 && this.restrictedHourRange.includes(24)\n      ) {\n        return false\n      }\n      return !this.restrictedHourRange.includes(+value)\n    },\n\n    notInInterval (section, value) {\n      if (!section || !this.isMinuteOrSecond(section)) { return }\n      if (this.opts[`${section}Interval`] === 1) { return false }\n      return +value % this.opts[`${section}Interval`] !== 0\n    },\n\n    renderRangeList (rawRange, section) {\n      if (!rawRange || !section || !this.isMinuteOrSecond(section)) { return [] }\n      const range = []\n      let formatedValue\n      rawRange.forEach(value => {\n        if (value instanceof Array) {\n          if (value.length > 2 && this.debugMode) {\n            this.debugLog(`Nested array within \"${section}-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n          }\n          const start = value[0]\n          const end = value[1] || value[0]\n          for (let i = +start; i <= +end; i++) {\n            if (i < 0 || i > 59) { continue }\n            formatedValue = this.formatValue(this.getTokenByType(section), i)\n            if (!range.includes(formatedValue)) {\n              range.push(formatedValue)\n            }\n          }\n        } else {\n          if (+value < 0 || +value > 59) { return }\n          formatedValue = this.formatValue(this.getTokenByType(section), value)\n          if (!range.includes(formatedValue)) {\n            range.push(formatedValue)\n          }\n        }\n      })\n      range.sort((l, r) => { return l - r })\n      // Debug Mode\n      if (this.debugMode) {\n        const fullList = (section === 'minute' ? this.minutes : this.seconds) || []\n        const validItems = fullList.filter(item => range.includes(item))\n        if (!validItems || !validItems.length) {\n          if (section === 'minute') {\n            this.debugLog(`The minute list is empty due to the \"minute-range\" config\\nminute-range: ${JSON.stringify(this.minuteRange)}\\nminute-interval: ${this.opts.minuteInterval}`)\n          } else {\n            this.debugLog(`The second list is empty due to the \"second-range\" config\\nsecond-range: ${JSON.stringify(this.secondRange)}\\nsecond-interval: ${this.opts.secondInterval}`)\n          }\n        }\n      }\n      return range\n    },\n\n    forceApmSelection () {\n      if (this.manualInput) {\n        // Skip this to allow users to paste a string value from the clipboard in Manual Input mode\n        return\n      }\n      if (this.apmType && !this.apm) {\n        if (this.has.am || this.has.pm) {\n          this.doClearApmChecking = true\n          const apmValue = this.has.am ? 'am' : 'pm'\n          this.apm = this.apmType === 'A' ? apmValue.toUpperCase() : apmValue\n        }\n      }\n    },\n\n    emptyApmSelection () {\n      if (this.doClearApmChecking && this.hour === '' && this.minute === '' && this.second === '') {\n        this.apm = ''\n      }\n      this.doClearApmChecking = false\n    },\n\n    apmDisplayText (apmValue) {\n      if (this.amText && this.lowerCasedApm(apmValue) === 'am') {\n        return this.amText\n      }\n      if (this.pmText && this.lowerCasedApm(apmValue) === 'pm') {\n        return this.pmText\n      }\n      return apmValue\n    },\n\n    toggleActive () {\n      if (this.disabled) { return }\n      this.isActive = !this.isActive\n\n      if (this.isActive) {\n        this.isFocusing = true\n        if (this.manualInput) {\n          this.$emit('focus')\n        }\n        if (!this.opts.hideDropdown) {\n          this.setDropdownState(true)\n        }\n        // Record to check if value did change in the later phase\n        if (this.lazy) {\n          this.bakDisplayTime = String(this.displayTime || '')\n        }\n        if (this.manualInput && !this.inputIsEmpty) {\n          this.$nextTick(() => {\n            if (this.$refs.input && this.$refs.input.selectionStart === 0 && this.$refs.input.selectionEnd === this.displayTime.length) {\n              // Select the first slot instead of the whole value string when tabbed in\n              this.selectFirstSlot()\n            }\n          })\n        }\n      } else {\n        if (this.showDropdown) {\n          this.setDropdownState(false)\n        } else if (this.manualInput) {\n          this.$emit('blur', this.getFullData())\n        }\n        this.isFocusing = false\n        if (this.lazy) {\n          this.fillValues(true)\n          this.bakDisplayTime = undefined\n        }\n      }\n\n      if (this.restrictedHourRange && this.baseOn12Hours) {\n        this.showDropdown ? this.forceApmSelection() : this.emptyApmSelection()\n      }\n      if (this.showDropdown) {\n        this.checkForAutoScroll()\n      }\n    },\n\n    setDropdownState (toShow, fromUserClick = false) {\n      if (toShow) {\n        if (this.appendToBody) {\n          this.appendDropdownToBody()\n        }\n        this.keepFocusing()\n        if (this.autoDirectionEnabled) {\n          this.checkDropDirection()\n        }\n        this.showDropdown = true\n        this.$emit('open') \n        if (fromUserClick) {\n          if (this.fixedDropdownButton) {\n            this.isActive = true\n          }\n          this.$emit('blur', this.getFullData())\n          this.checkForAutoScroll()\n        }\n      } else {\n        this.showDropdown = false\n        this.$emit('close', this.getFullData())\n        if (this.appendToBody) {\n          this.removeDropdownFromBody()\n        }\n      }\n    },\n\n    appendDropdownToBody () {\n      const dropdown = this.$refs && this.$refs.dropdown\n      const body = document.getElementsByTagName('body')[0]\n      if (body && dropdown) {\n        window.addEventListener('scroll', this.updateDropdownPos)\n        dropdown.classList.add('vue__time-picker-dropdown')\n        this.updateDropdownPos()\n        body.appendChild(dropdown)\n      }\n    },\n\n    updateDropdownPos () {\n      if (!this.appendToBody) { return }\n      const dropdown = this.$refs && this.$refs.dropdown\n      const body = document.getElementsByTagName('body')[0]\n      if (body && dropdown) {\n        const box = this.$el.getBoundingClientRect()\n        if (this.dropdownDirClass === 'drop-up') {\n          dropdown.style.bottom = `${window.innerHeight - box.y}px`\n          dropdown.style.top = 'auto'\n        } else {\n          dropdown.style.top = `${box.y + box.height}px`\n          dropdown.style.bottom = 'auto'\n        }\n        dropdown.style.left = `${box.x}px`\n      }\n    },\n\n    removeDropdownFromBody () {\n      const dropdown = this.$refs && this.$refs.dropdown\n      const body = document.getElementsByTagName('body')[0]\n      if (body && dropdown && body.contains(dropdown)) {\n        body.removeChild(dropdown)\n      }\n      if (dropdown) {\n        dropdown.classList.remove('vue__time-picker-dropdown')\n        dropdown.style.top = ''\n        dropdown.style.bottom = ''\n        dropdown.style.left = ''\n        this.$el.appendChild(dropdown)\n      }\n      window.removeEventListener('scroll', this.updateDropdownPos)\n    },\n\n    blurEvent () {\n      if (this.manualInput && !this.opts.hideDropdown) {\n        // hideDropdown's `blur` event is handled somewhere else\n        this.$emit('blur', this.getFullData())\n      }\n    },\n\n    select (type, value) {\n      if (this.isBasicType(type) && !this.isDisabled(type, value)) {\n        this[type] = value\n        if (this.doClearApmChecking) {\n          this.doClearApmChecking = false\n        }\n      }\n    },\n\n    clearTime () {\n      if (this.disabled) { return }\n      this.hour = ''\n      this.minute = ''\n      this.second = ''\n      this.apm = ''\n\n      if (this.manualInput && this.$refs && this.$refs.input && this.$refs.input.value.length) {\n        this.$refs.input.value = ''\n      }\n\n      if (this.lazy) {\n        this.fillValues(true)\n      }\n    },\n\n    //\n    // Auto-Scroll\n    //\n\n    checkForAutoScroll () {\n      if (this.inputIsEmpty) { return }\n      if (this.autoScroll) {\n        this.$nextTick(() => {\n          this.scrollToSelectedValues()\n        })\n      } else if (this.advancedKeyboard) {\n        // Auto-focus on selected value in the first column for advanced-keyboard\n        this.$nextTick(() => {\n          const firstColumn = this.inUse.types[0]\n          this.scrollToSelected(firstColumn, true)\n        })\n      }\n    },\n\n    scrollToSelected (column, allowFallback = false) {\n      if (!this.timeValue || this.inputIsEmpty) { return }\n      let targetList\n      if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n        targetList = this.$refs.dropdown.querySelectorAll(`ul.${column}s`)[0]\n      } else {\n        targetList = this.$el.querySelectorAll(`ul.${column}s`)[0]\n      }\n      let targetValue = this.activeItemInCol(column)[0]\n      if (!targetValue && allowFallback) {\n        // No value selected in the target column, fallback to the first found valid item\n        targetValue = this.validItemsInCol(column)[0]\n      }\n      if (targetList && targetValue) {\n        targetList.scrollTop = targetValue.offsetTop || 0\n        if (this.advancedKeyboard) {\n          targetValue.focus()\n        }\n      }\n    },\n\n    scrollToSelectedValues () {\n      if (!this.timeValue || this.inputIsEmpty) { return }\n      this.inUse.types.forEach(section => {\n        this.scrollToSelected(section)\n      })\n    },\n\n    //\n    // Additional Keyboard Navigation\n    //\n\n    onFocus () {\n      if (this.disabled) { return }\n      if (!this.isFocusing) {\n        this.isFocusing = true\n      }\n      if (!this.isActive) {\n        this.toggleActive()\n      }\n    },\n\n    escBlur () {\n      if (this.disabled) { return }\n      window.clearTimeout(this.debounceTimer)\n      this.isFocusing = false\n      const inputBox = this.$el.querySelectorAll('input.display-time')[0]\n      if (inputBox) {\n        inputBox.blur()\n      }\n    },\n\n    debounceBlur () {\n      if (this.disabled) { return }\n      this.isFocusing = false\n      window.clearTimeout(this.debounceTimer)\n      this.debounceTimer = window.setTimeout(() => {\n        window.clearTimeout(this.debounceTimer)\n        this.onBlur()\n      }, this.opts.blurDelay)\n    },\n\n    onBlur () {\n      if (!this.disabled && !this.isFocusing && this.isActive) {\n        this.toggleActive()\n      }\n    },\n\n    keepFocusing () {\n      if (this.disabled) { return }\n      window.clearTimeout(this.debounceTimer)\n      if (!this.isFocusing) {\n        this.isFocusing = true\n      }\n    },\n\n    onTab (column, value, evt) {\n      if (this.appendToBody && evt.shiftKey) {\n        const firstColumn = this.inUse.types[0]\n        if (column !== firstColumn) { return }\n        const firstValidValue = this.validItemsInCol(firstColumn)[0]\n        // Is the first valid item in the first column\n        if (firstValidValue && firstValidValue.getAttribute('data-key') === String(value)) {\n          evt.preventDefault()\n          // Focus back on <input>\n          if (this.$refs && this.$refs.input) {\n            this.$refs.input.focus()\n          }\n        }\n      }\n    },\n\n    validItemsInCol (column) {\n      const columnClass = `${column}s`\n      if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n        return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n      }\n      return this.$el.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n    },\n\n    activeItemInCol (column) {\n      const columnClass = `${column}s`\n      if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n        return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n      }\n      return this.$el.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n    },\n\n    getClosestSibling (column, dataKey, getPrevious = false) {\n      const siblingsInCol = this.validItemsInCol(column)\n      const selfIndex = Array.prototype.findIndex.call(siblingsInCol, (sbl) => {\n        return sbl.getAttribute('data-key') === dataKey\n      })\n\n      // Already the first item\n      if (getPrevious && selfIndex === 0) {\n        return siblingsInCol[siblingsInCol.length - 1]\n      }\n      // Already the last item\n      if (!getPrevious && selfIndex === siblingsInCol.length - 1) {\n        return siblingsInCol[0]\n      }\n      // Selected value not in the valid values list\n      if (selfIndex < 0) {\n        return siblingsInCol[0]\n      }\n\n      if (getPrevious) {\n        return siblingsInCol[selfIndex - 1]\n      }\n      return siblingsInCol[selfIndex + 1]\n    },\n\n    prevItem (column, dataKey, isManualInput = false) {\n      const targetItem = this.getClosestSibling(column, dataKey, true)\n      if (targetItem) {\n        return isManualInput ? targetItem : targetItem.focus()\n      }\n    },\n\n    nextItem (column, dataKey, isManualInput = false) {\n      const targetItem = this.getClosestSibling(column, dataKey, false)\n      if (targetItem) {\n        return isManualInput ? targetItem : targetItem.focus()\n      }\n    },\n\n    getSideColumnName (currentColumn, toLeft = false) {\n      const currentColumnIndex = this.inUse.types.indexOf(currentColumn)\n      if (toLeft && currentColumnIndex <= 0) {\n        if (this.debugMode) {\n          this.debugLog('You\\'re in the leftmost list already')\n        }\n        return\n      } else if (!toLeft && currentColumnIndex === (this.inUse.types.length - 1)) {\n        if (this.debugMode) {\n          this.debugLog('You\\'re in the rightmost list already')\n        }\n        return\n      }\n      return this.inUse.types[toLeft ? currentColumnIndex - 1 : currentColumnIndex + 1]\n    },\n\n    getFirstItemInSideColumn (currentColumn, toLeft = false) {\n      const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n      if (!targetColumn) { return }\n      const listItems = this.validItemsInCol(targetColumn)\n      if (listItems && listItems[0]) {\n        return listItems[0]\n      }\n    },\n\n    getActiveItemInSideColumn (currentColumn, toLeft = false) {\n      const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n      if (!targetColumn) { return }\n      const activeItems = this.activeItemInCol(targetColumn)\n      if (activeItems && activeItems[0]) {\n        return activeItems[0]\n      }\n    },\n\n    toLeftColumn (currentColumn) {\n      const targetItem = this.getActiveItemInSideColumn(currentColumn, true) || this.getFirstItemInSideColumn(currentColumn, true)\n      if (targetItem) {\n        targetItem.focus()\n      }\n    },\n\n    toRightColumn (currentColumn) {\n      const targetItem = this.getActiveItemInSideColumn(currentColumn, false) || this.getFirstItemInSideColumn(currentColumn, false)\n      if (targetItem) {\n        targetItem.focus()\n      }\n    },\n\n    //\n    // Manual Input\n    //\n\n    onMouseDown () {\n      if (!this.manualInput) { return }\n      window.clearTimeout(this.selectionTimer)\n      this.selectionTimer = window.setTimeout(() => {\n        window.clearTimeout(this.selectionTimer)\n        if (this.$refs && this.$refs.input) {\n          const nearestSlot = this.getNearestChunkByPos(this.$refs.input.selectionStart || 0)\n          this.debounceSetInputSelection(nearestSlot)\n        }\n      }, 50)\n    },\n\n    keyDownHandler (evt) {\n      if (evt.isComposing || evt.keyCode === 229) {\n        // Skip IME inputs\n        evt.preventDefault()\n        evt.stopPropagation()\n        return false\n      }\n      // Numbers\n      if ((evt.keyCode >= 48 && evt.keyCode <= 57) || (evt.keyCode >= 96 && evt.keyCode <= 105)) {\n        evt.preventDefault()\n        this.keyboardInput(evt.key)\n      // A|P|M\n      } else if ([65, 80, 77].includes(evt.keyCode)) {\n        evt.preventDefault()\n        this.keyboardInput(evt.key, true)\n      // Arrow keys\n      } else if (evt.keyCode >= 37 && evt.keyCode <= 40) {\n        evt.preventDefault()\n        this.clearKbInputLog()\n        this.arrowHandler(evt)\n      // Delete|Backspace\n      } else if (evt.keyCode === 8 || evt.keyCode === 46) {\n        evt.preventDefault()\n        this.clearKbInputLog()\n        this.clearTime()\n      // Tab\n      } else if (evt.keyCode === 9) {\n        this.clearKbInputLog()\n        this.tabHandler(evt)\n      // Colon|Space\n      } else if (evt.keyCode === 186 || evt.keyCode === 32) {\n        evt.preventDefault()\n        this.clearKbInputLog()\n        this.toNextSlot()\n      // Prevent any Non-ESC and non-pasting inputs\n      } else if (evt.keyCode !== 27 && !(evt.metaKey || evt.ctrlKey)) {\n        evt.preventDefault()\n      }\n    },\n\n    onCompostionStart (evt) {\n      evt.preventDefault()\n      evt.stopPropagation()\n      this.bakCurrentPos = this.getCurrentTokenChunk()\n      return false\n    },\n\n    onCompostionEnd (evt) {\n      evt.preventDefault()\n      evt.stopPropagation()\n\n      const cpsData = evt.data\n      let inputIsCustomApmText = false\n      if (this.has.customApmText) {\n        inputIsCustomApmText = this.isCustomApmText(cpsData)\n      }\n      if (inputIsCustomApmText) {\n        this.setSanitizedValueToSection('apm', inputIsCustomApmText)\n      }\n\n      this.$refs.input.value = this.has.customApmText ? this.customDisplayTime : this.displayTime\n\n      this.$nextTick(() => {\n        if (this.bakCurrentPos) {\n          const bakPos = JSON.parse(JSON.stringify(this.bakCurrentPos))\n          if (inputIsCustomApmText) {\n            bakPos.end = (bakPos.start + cpsData.length)\n          }\n          this.debounceSetInputSelection(bakPos)\n          this.bakCurrentPos = null\n        }\n      })\n      return false\n    },\n\n    pasteHandler (evt) {\n      evt.preventDefault()\n      let pastingText = (evt.clipboardData || window.clipboardData).getData('text')\n      if (this.debugMode) {\n        this.debugLog(`Pasting value \"${pastingText}\" from clipboard`)\n      }\n      if (!pastingText || !pastingText.length) { return }\n\n      // Replace custom AM/PM text (if any)\n      if (this.has.customApmText) {\n        pastingText = this.replaceCustomApmText(pastingText)\n      }\n\n      if (this.inputIsEmpty) {\n        this.readStringValues(pastingText)\n      } else {\n        this.kbInputLog = pastingText.substr(-2, 2)\n        this.setKbInput()\n        this.debounceClearKbLog()\n      }\n    },\n\n    arrowHandler (evt) {\n      const direction = { 37: 'L', 38: 'U', 39: 'R', 40: 'D' }[evt.keyCode]\n      if (direction === 'U' || direction === 'D') {\n        if (this.inputIsEmpty) {\n          this.selectFirstValidValue()\n        } else {\n          const currentChunk = this.getCurrentTokenChunk()\n          if (!currentChunk) {\n            this.selectFirstValidValue()\n            return\n          }\n          const tokenType = currentChunk.type\n          this.getClosestValidItemInCol(tokenType, this[tokenType], direction)\n          const newChunkPos = this.getCurrentTokenChunk()\n          this.debounceSetInputSelection(newChunkPos)\n        }\n      } else if (direction === 'R') {\n        this.toLateralToken(false)\n      } else if (direction === 'L') {\n        this.toLateralToken(true)\n      }\n    },\n\n    tabHandler (evt) {\n      if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n        const currentChunk = this.getCurrentTokenChunk()\n        if (!currentChunk) { return }\n        const firstChunk = this.tokenChunksPos[0]\n        const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n        if ((evt.shiftKey && currentChunk.token !== firstChunk.token) || (!evt.shiftKey && currentChunk.token !== lastChunk.token)) {\n          evt.preventDefault()\n          this.toLateralToken(evt.shiftKey)\n        }\n      } else if (this.appendToBody && this.advancedKeyboard) {\n        if (evt.shiftKey) { return }\n        evt.preventDefault()\n        if (this.inputIsEmpty) {\n          const firstColumn = this.inUse.types[0]\n          const targetValue = this.validItemsInCol(firstColumn)[0]\n          if (targetValue) {\n            targetValue.focus()\n          }\n        }\n      }\n    },\n\n    keyboardInput (newChar, isApm = false) {\n      const currentChunk = this.getCurrentTokenChunk()\n      if (!currentChunk || (currentChunk.type !== 'apm' && isApm) || (currentChunk.type === 'apm' && !isApm)) { return }\n      this.kbInputLog = `${this.kbInputLog.substr(-1)}${newChar}`\n      this.setKbInput()\n      this.debounceClearKbLog()\n    },\n\n    clearKbInputLog () {\n      window.clearTimeout(this.kbInputTimer)\n      this.kbInputLog = ''\n    },\n\n    debounceClearKbLog () {\n      window.clearTimeout(this.kbInputTimer)\n      this.kbInputTimer = window.setTimeout(() => {\n        this.clearKbInputLog()\n      }, this.opts.manualInputTimeout)\n    },\n\n    setKbInput (value) {\n      value = value || this.kbInputLog\n      const currentChunk = this.getCurrentTokenChunk()\n      if (!currentChunk || !value || !value.length) { return }\n      const chunkType = currentChunk.type\n      const chunkToken = currentChunk.token\n\n      let validValue\n      if (chunkType === 'apm') {\n        if (this.lowerCasedApm(value).includes('a')) {\n          validValue = 'am'\n        } else if (this.lowerCasedApm(value).includes('p')) {\n          validValue = 'pm'\n        }\n        if (validValue) {\n          validValue = chunkToken === 'A' ? validValue.toUpperCase() : validValue\n        }\n      } else {\n        if (this.isValidValue(chunkToken, value)) {\n          validValue = value\n        } else {\n          const lastInputValue = this.formatValue(chunkToken, value.substr(-1))\n          if (this.isValidValue(chunkToken, lastInputValue)) {\n            validValue = lastInputValue\n          }\n        }\n      }\n\n      if (validValue) {\n        this.setSanitizedValueToSection(chunkType, validValue)\n        const newChunkPos = this.getCurrentTokenChunk()\n        this.debounceSetInputSelection(newChunkPos)      \n      }\n      if (this.debugMode) {\n        if (validValue) {\n          this.debugLog(`Successfully set value \"${validValue}\" from latest input \"${value}\" for the \"${chunkType}\" slot`)\n        } else {\n          this.debugLog(`Value \"${value}\" is invalid in the \"${chunkType}\" slot`)\n        }\n      }\n    },\n\n    // Form Autofill\n    onChange () {\n      if (!this.manualInput || !this.$refs || !this.$refs.input) { return }\n      const autoFillValue = this.$refs.input.value || ''\n      if (autoFillValue && autoFillValue.length) {\n        this.readStringValues(autoFillValue)\n      }\n    },\n\n    getNearestChunkByPos (startPos) {\n      if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n      let nearest\n      let nearestDelta = -1\n      for (let i = 0; i < this.tokenChunksPos.length; i++) {\n        const chunk = JSON.parse(JSON.stringify(this.tokenChunksPos[i]))\n        if (chunk.start === startPos) {\n          return chunk\n        }\n        const delta = Math.abs(chunk.start - startPos)\n        if (nearestDelta < 0) {\n          nearest = chunk\n          nearestDelta = delta\n        } else {\n          if (nearestDelta <= delta) {\n            return nearest\n          }\n          nearestDelta = delta\n          nearest = chunk\n        }\n      }\n      return nearest\n    },\n\n    selectFirstValidValue () {\n      if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n      const firstSlotType = this.tokenChunksPos[0].type\n      if (firstSlotType === 'hour') {\n        this.getClosestHourItem()\n      } else {\n        this.getClosestValidItemInCol(firstSlotType, this[firstSlotType])\n      }\n      this.selectFirstSlot()\n    },\n\n    getClosestHourItem (currentValue, direction = 'U') {\n      if (!this.validHoursList || !this.validHoursList.length) {\n        if (this.debugMode) {\n          this.debugLog(`No valid hour values found, please check your \"hour-range\" config\\nhour-range: ${JSON.stringify(this.hourRange)}`)\n        }\n        return\n      }\n      if (!currentValue) {\n        this.setManualHour(this.validHoursList[0])\n        return\n      }\n      const currentIndex = this.validHoursList.findIndex(item => {\n        if (!this.baseOn12Hours) {\n          return item === currentValue\n        } else {\n          const valueKey = `${currentValue}${this.lowerCasedApm(this.apm) === 'pm' ? 'p' : 'a'}` \n          return item === valueKey\n        }\n      })\n      let nextIndex\n      if (currentIndex === -1) {\n        nextIndex = 0\n      } else if (direction === 'D') {\n        nextIndex = currentIndex === 0 ? this.validHoursList.length - 1 : currentIndex - 1\n      } else {\n        nextIndex = (currentIndex + 1) % this.validHoursList.length\n      }\n      const nextItem = this.validHoursList[nextIndex]\n      this.setManualHour(nextItem)\n    },\n\n    getClosestValidItemInCol (column, currentValue, direction = 'U') {\n      if (column === 'hour') {\n        this.getClosestHourItem(currentValue, direction)\n      } else {\n        const nextItem = direction === 'D' ? this.prevItem(column, this[column], true) : this.nextItem(column, this[column], true)\n        if (nextItem) {\n          this.select(column, nextItem.getAttribute('data-key'))\n        }\n      }\n    },\n\n    setSanitizedValueToSection (section, inputValue) {\n      if (!section || !this.getTokenByType(section)) { return }\n      // NOTE: Disabled values are allowed here, followed by an 'error' event, though\n      const sanitizedValue = this.sanitizedValue(this.getTokenByType(section), inputValue)\n      this[section] = sanitizedValue\n    },\n\n    setManualHour (nextItem) {\n      if (this.is12hRange(nextItem)) {\n        const hourT = this.match12hRange(nextItem)\n        const apmValue = hourT[2] === 'a' ? 'AM' : 'PM'\n        this.setSanitizedValueToSection('apm', this.apmType === 'a' ? apmValue.toLowerCase() : apmValue)\n        this.setSanitizedValueToSection('hour', hourT[1])\n      } else {\n        this.setSanitizedValueToSection('hour', nextItem)\n      }\n    },\n\n    debounceSetInputSelection ({start = 0, end = 0 }) {\n      this.$nextTick(() => {\n        this.setInputSelectionRange(start, end)\n      })\n      window.clearTimeout(this.selectionTimer)\n      this.selectionTimer = window.setTimeout(() => {\n        window.clearTimeout(this.selectionTimer)\n        // Double-check selection for 12hr format\n        if (this.$refs.input && (this.$refs.input.selectionStart !== start || this.$refs.input.selectionEnd !== end)) {\n          this.setInputSelectionRange(start, end)\n        }\n      }, 30)\n    },\n\n    setInputSelectionRange (start, end) {\n      if (this.$refs && this.$refs.input) {\n        this.$refs.input.setSelectionRange(start, end)\n      }\n    },\n\n    getCurrentTokenChunk () {\n      return this.getNearestChunkByPos((this.$refs.input && this.$refs.input.selectionStart) || 0)\n    },\n\n    selectFirstSlot () {\n      const firstChunkPos = this.getNearestChunkByPos(0)\n      this.debounceSetInputSelection(firstChunkPos)\n    },\n\n    toNextSlot () {\n      if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n        const currentChunk = this.getCurrentTokenChunk()\n        if (!currentChunk) { return }\n        const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n        if (currentChunk.token !== lastChunk.token) {\n          this.toLateralToken(false)\n        }\n      }\n    },\n\n    toLateralToken (toLeft) {\n      const currentChunk = this.getCurrentTokenChunk()\n      if (!currentChunk) {\n        this.selectFirstValidValue()\n        return\n      }\n      const currentChunkIndex = this.tokenChunksPos.findIndex(chk => chk.token === currentChunk.token)\n      if ((!toLeft && currentChunkIndex >= this.tokenChunksPos.length - 1) || (toLeft && currentChunkIndex === 0)) {\n        if (this.debugMode) {\n          if (toLeft) {\n            this.debugLog('You\\'re in the leftmost slot already')\n          } else {\n            this.debugLog('You\\'re in the rightmost slot already')\n          }\n        }\n        return\n      }\n      const targetSlotPos = toLeft ? this.tokenChunksPos[currentChunkIndex - 1] : this.tokenChunksPos[currentChunkIndex + 1]\n      this.debounceSetInputSelection(targetSlotPos)\n    },\n\n    isCustomApmText (inputData) {\n      if (!inputData || !inputData.length) { return false }\n      if (this.amText && this.amText === inputData) {\n        return this.apmType === 'A' ? 'AM' : 'am'\n      }\n      if (this.pmText && this.pmText === inputData) {\n        return this.apmType === 'A' ? 'PM' : 'pm'\n      }\n      return false\n    },\n\n    replaceCustomApmText (inputString) {\n      if (this.amText && this.amText.length && inputString.includes(this.amText)) {\n        return inputString.replace(new RegExp(this.amText, 'g'), this.apmType === 'A' ? 'AM' : 'am')\n      } else if (this.pmText && this.pmText.length && inputString.includes(this.pmText)) {\n        return inputString.replace(new RegExp(this.pmText, 'g'), this.apmType === 'A' ? 'PM' : 'pm')\n      }\n      return inputString\n    },\n\n    checkDropDirection () {\n      if (!this.$el) { return }\n      let container\n      if (this.containerId && this.containerId.length) {\n        container = document.getElementById(this.containerId)\n        if (!container && this.debugMode) {\n          this.debugLog(`Container with id \"${this.containerId}\" not found. Fallback to document body.`)\n        }\n      }\n      const el = this.$el\n      let spaceDown\n      if (container && container.offsetHeight) {\n        // Valid container found\n        spaceDown = (container.offsetTop + container.offsetHeight) - (el.offsetTop + el.offsetHeight)\n      } else {\n        // Fallback to document body\n        const docHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)\n        spaceDown = docHeight - (el.offsetTop + el.offsetHeight)\n      }\n      this.forceDropOnTop = this.opts.dropOffsetHeight > spaceDown\n    },\n\n    //\n    // Helpers\n    //\n\n    is12hRange (value) {\n      return /^\\d{1,2}(a|p|A|P)$/.test(value)\n    },\n\n    match12hRange (value) {\n      return value.match(/^(\\d{1,2})(a|p|A|P)$/)\n    },\n\n    isNumber (value) {\n      return !isNaN(parseFloat(value)) && isFinite(value)\n    },\n\n    isBasicType (type) {\n      return CONFIG.BASIC_TYPES.includes(type)\n    },\n\n    lowerCasedApm (apmValue) {\n      return (apmValue || '').toLowerCase()\n    },\n\n    getTokenRegex (token) {\n      switch (token) {\n        case 'HH':\n          return '([01][0-9]|2[0-3]|H{2})'\n        case 'H':\n          return '([0-9]{1}|1[0-9]|2[0-3]|H{1})'\n        case 'hh':\n          return '(0[1-9]|1[0-2]|h{2})'\n        case 'h':\n          return '([1-9]{1}|1[0-2]|h{1})'\n        case 'kk':\n          return '(0[1-9]|1[0-9]|2[0-4]|k{2})'\n        case 'k':\n          return '([1-9]{1}|1[0-9]|2[0-4]|k{1})'\n        case 'mm':\n          return '([0-5][0-9]|m{2})'\n        case 'ss':\n          return '([0-5][0-9]|s{2})'\n        case 'm':\n          return '([0-9]{1}|[1-5][0-9]|m{1})'\n        case 's':\n          return '([0-9]{1}|[1-5][0-9]|s{1})'\n        case 'A':\n          return '(AM|PM|A{1})'\n        case 'a':\n          return '(am|pm|a{1})'\n        default:\n          return ''\n      }\n    },\n\n    isEmptyValue (targetToken, testValue) {\n      return (!testValue || !testValue.length) || (testValue && testValue === targetToken)\n    },\n\n    isValidValue (targetToken, testValue) {\n      if (!targetToken || this.isEmptyValue(targetToken, testValue)) { return false }\n      const tokenRegexStr = this.getTokenRegex(targetToken)\n      if (!tokenRegexStr || !tokenRegexStr.length) { return false }\n      return (new RegExp(`^${tokenRegexStr}$`)).test(testValue)\n    },\n\n    sanitizedValue (targetToken, inputValue) {\n      if (this.isValidValue(targetToken, inputValue)) {\n        return inputValue\n      }\n      return ''\n    },\n\n    getTokenType (token) {\n      return this.inUse.types[this.inUse.tokens.indexOf(token)] || ''\n    },\n\n    getTokenByType (type) {\n      return this[`${type}Type`] || ''\n    },\n\n    isMinuteOrSecond (type) {\n      return ['minute', 'second'].includes(type)\n    },\n\n    debugLog (logText) {\n      if (!logText || !logText.length) { return }\n      let identifier = ''\n      if (this.id) {\n        identifier += `#${this.id}`\n      }\n      if (this.name) {\n        identifier += `[name=${this.name}]`\n      }\n      if (this.inputClass) {\n        let inputClasses = []\n        if (typeof this.inputClass === 'string') {\n          inputClasses = this.inputClass.split(/\\s/g)\n        } else if (Array.isArray(this.inputClass)) {\n          inputClasses = [].concat([], this.inputClass)\n        } else if (typeof this.inputClass === 'object') {\n          Object.keys(this.inputClass).forEach(clsName => {\n            if (this.inputClass[clsName]) {\n              inputClasses.push(clsName)\n            }\n          })\n        }\n        for (let inputClass of inputClasses) {\n          if (inputClass && inputClass.trim().length) {\n            identifier += `.${inputClass.trim()}`\n          }\n        }\n      }\n      const finalLogText = `DEBUG: ${logText}${identifier ? `\\n\\t(${identifier})` : '' }`\n      if (window.console.debug && typeof window.console.debug === 'function') {\n        window.console.debug(finalLogText)\n      } else {\n        window.console.log(finalLogText)\n      }\n    }\n  },\n\n  mounted () {\n    window.clearTimeout(this.debounceTimer)\n    window.clearTimeout(this.selectionTimer)\n    window.clearTimeout(this.kbInputTimer)\n    this.renderFormat()\n  },\n\n  beforeDestroy () {\n    window.clearTimeout(this.debounceTimer)\n    window.clearTimeout(this.selectionTimer)\n    window.clearTimeout(this.kbInputTimer)\n  }\n}\n</script>\n\n<template>\n<span class=\"vue__time-picker time-picker\" :style=\"inputWidthStyle\">\n  <input type=\"text\" class=\"display-time\" ref=\"input\"\n         :class=\"[inputClass, {'is-empty': inputIsEmpty, 'invalid': hasInvalidInput, 'all-selected': allValueSelected, 'disabled': disabled, 'has-custom-icon': $slots && $slots.icon }]\"\n         :style=\"inputWidthStyle\"\n         :id=\"id\"\n         :name=\"name\"\n         :value=\"inputIsEmpty ? null : customDisplayTime\"\n         :placeholder=\"placeholder ? placeholder : formatString\"\n         :tabindex=\"disabled ? -1 : tabindex\"\n         :disabled=\"disabled\"\n         :readonly=\"!manualInput\"\n         :autocomplete=\"autocomplete\"\n         @focus=\"onFocus\"\n         @change=\"onChange\"\n         @blur=\"debounceBlur(); blurEvent()\"\n         @mousedown=\"onMouseDown\"\n         @keydown=\"keyDownHandler\"\n         @compositionstart=\"onCompostionStart\"\n         @compositionend=\"onCompostionEnd\"\n         @paste=\"pasteHandler\"\n         @keydown.esc.exact=\"escBlur\" />\n  <div class=\"controls\" v-if=\"showClearBtn || showDropdownBtn\" tabindex=\"-1\">\n    <span v-if=\"!isActive && showClearBtn\" class=\"clear-btn\" tabindex=\"-1\"\n          :class=\"{'has-custom-btn': $slots && $slots.clearButton }\"\n          @click=\"clearTime\">\n      <slot name=\"clearButton\"><span class=\"char\">&times;</span></slot>\n    </span>\n    <span v-if=\"showDropdownBtn\" class=\"dropdown-btn\" tabindex=\"-1\"\n          :class=\"{'has-custom-btn': $slots && $slots.dropdownButton }\"\n          @click=\"setDropdownState(fixedDropdownButton ? !showDropdown : true, true)\"\n          @mousedown=\"keepFocusing\">\n      <slot name=\"dropdownButton\"><span class=\"char\">&dtrif;</span></slot>\n    </span>\n  </div>\n  <div class=\"custom-icon\" v-if=\"$slots && $slots.icon\"><slot name=\"icon\"></slot></div>\n  <div class=\"time-picker-overlay\" v-if=\"showDropdown\" @click=\"toggleActive\" tabindex=\"-1\"></div>\n  <div class=\"dropdown\" ref=\"dropdown\" v-show=\"showDropdown\" tabindex=\"-1\"\n       :class=\"[dropdownDirClass]\" :style=\"inputWidthStyle\"\n       @mouseup=\"keepFocusing\" @click.stop=\"\">\n    <div class=\"select-list\" :style=\"inputWidthStyle\" tabindex=\"-1\">\n      <!-- Common Keyboard Support: less event listeners -->\n      <template v-if=\"!advancedKeyboard\">\n        <template v-for=\"column in columnsSequence\">\n          <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"hourLabelText\"></li>\n            <template v-for=\"(hr, hIndex) in hours\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                  :key=\"hIndex\"\n                  :class=\"{active: hour === hr}\"\n                  :disabled=\"isDisabled('hour', hr)\"\n                  :data-key=\"hr\"\n                  v-text=\"hr\"\n                  @click=\"select('hour', hr)\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"minuteLabelText\"></li>\n            <template v-for=\"(m, mIndex) in minutes\">\n              <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                  :key=\"mIndex\"\n                  :class=\"{active: minute === m}\"\n                  :disabled=\"isDisabled('minute', m)\"\n                  :data-key=\"m\"\n                  v-text=\"m\"\n                  @click=\"select('minute', m)\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"secondLabelText\"></li>\n            <template v-for=\"(s, sIndex) in seconds\">\n              <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                  :key=\"sIndex\"\n                  :class=\"{active: second === s}\"\n                  :disabled=\"isDisabled('second', s)\"\n                  :data-key=\"s\"\n                  v-text=\"s\"\n                  @click=\"select('second', s)\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"apmLabelText\"></li>\n            <template v-for=\"(a, aIndex) in apms\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                  :key=\"aIndex\"\n                  :class=\"{active: apm === a}\"\n                  :disabled=\"isDisabled('apm', a)\"\n                  :data-key=\"a\"\n                  v-text=\"apmDisplayText(a)\"\n                  @click=\"select('apm', a)\"></li>\n            </template>\n          </ul>\n        </template>\n      </template><!-- / Common Keyboard Support -->\n\n      <!--\n        Advanced Keyboard Support\n        Addeds hundreds of additional event lisenters\n      -->\n      <template v-if=\"advancedKeyboard\">\n        <template v-for=\"column in columnsSequence\">\n          <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"hourLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(hr, hIndex) in hours\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                  :key=\"hIndex\"\n                  :class=\"{active: hour === hr}\"\n                  :tabindex=\"isDisabled('hour', hr) ? -1 : tabindex\"\n                  :data-key=\"hr\"\n                  :disabled=\"isDisabled('hour', hr)\"\n                  v-text=\"hr\"\n                  @click=\"select('hour', hr)\"\n                  @keydown.tab=\"onTab('hour', hr, $event)\"\n                  @keydown.space.prevent=\"select('hour', hr)\"\n                  @keydown.enter.prevent=\"select('hour', hr)\"\n                  @keydown.up.prevent=\"prevItem('hour', hr)\"\n                  @keydown.down.prevent=\"nextItem('hour', hr)\"\n                  @keydown.left.prevent=\"toLeftColumn('hour')\"\n                  @keydown.right.prevent=\"toRightColumn('hour')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"minuteLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(m, mIndex) in minutes\">\n              <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                  :key=\"mIndex\"\n                  :class=\"{active: minute === m}\"\n                  :tabindex=\"isDisabled('minute', m) ? -1 : tabindex\"\n                  :data-key=\"m\"\n                  :disabled=\"isDisabled('minute', m)\"\n                  v-text=\"m\"\n                  @click=\"select('minute', m)\"\n                  @keydown.tab=\"onTab('minute', m, $event)\"\n                  @keydown.space.prevent=\"select('minute', m)\"\n                  @keydown.enter.prevent=\"select('minute', m)\"\n                  @keydown.up.prevent=\"prevItem('minute', m)\"\n                  @keydown.down.prevent=\"nextItem('minute', m)\"\n                  @keydown.left.prevent=\"toLeftColumn('minute')\"\n                  @keydown.right.prevent=\"toRightColumn('minute')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"secondLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(s, sIndex) in seconds\">\n              <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                  :key=\"sIndex\"\n                  :class=\"{active: second === s}\"\n                  :tabindex=\"isDisabled('second', s) ? -1 : tabindex\"\n                  :data-key=\"s\"\n                  :disabled=\"isDisabled('second', s)\"\n                  v-text=\"s\"\n                  @click=\"select('second', s)\"\n                  @keydown.tab=\"onTab('second', s, $event)\"\n                  @keydown.space.prevent=\"select('second', s)\"\n                  @keydown.enter.prevent=\"select('second', s)\"\n                  @keydown.up.prevent=\"prevItem('second', s)\"\n                  @keydown.down.prevent=\"nextItem('second', s)\"\n                  @keydown.left.prevent=\"toLeftColumn('second')\"\n                  @keydown.right.prevent=\"toRightColumn('second')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"apmLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(a, aIndex) in apms\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                  :key=\"aIndex\"\n                  :class=\"{active: apm === a}\"\n                  :tabindex=\"isDisabled('apm', a) ? -1 : tabindex\"\n                  :data-key=\"a\"\n                  :disabled=\"isDisabled('apm', a)\"\n                  v-text=\"apmDisplayText(a)\"\n                  @click=\"select('apm', a)\"\n                  @keydown.tab=\"onTab('apm', a, $event)\"\n                  @keydown.space.prevent=\"select('apm', a)\"\n                  @keydown.enter.prevent=\"select('apm', a)\"\n                  @keydown.up.prevent=\"prevItem('apm', a)\"\n                  @keydown.down.prevent=\"nextItem('apm', a)\"\n                  @keydown.left.prevent=\"toLeftColumn('apm')\"\n                  @keydown.right.prevent=\"toRightColumn('apm')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n        </template>\n      </template><!-- / Advanced Keyboard Support -->\n    </div>\n  </div>\n</span>\n</template>\n\n<style>\n.vue__time-picker {\n  display: inline-block;\n  position: relative;\n  font-size: 1em;\n  width: 10em;\n  font-family: sans-serif;\n  vertical-align: middle;\n}\n\n.vue__time-picker * {\n  box-sizing: border-box;\n}\n\n.vue__time-picker input.display-time {\n  border: 1px solid #d2d2d2;\n  width: 10em;\n  height: 2.2em;\n  padding: 0.3em 0.5em;\n  font-size: 1em;\n}\n\n.vue__time-picker input.has-custom-icon {\n  padding-left: 1.8em;\n}\n\n.vue__time-picker input.display-time.invalid:not(.skip-error-style) {\n  border-color: #cc0033;\n  outline-color: #cc0033;\n}\n\n.vue__time-picker input.display-time:disabled,\n.vue__time-picker input.display-time.disabled {\n  color: #d2d2d2;\n}\n\n.vue__time-picker .controls {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  z-index: 3;\n\n  display: flex;\n  flex-flow: row nowrap;\n  justify-content: flex-end;\n  align-items: stretch;\n\n  /* Prevent browser focusing on the controls layer */\n  pointer-events: none;\n}\n\n.vue__time-picker .controls > * {\n  cursor: pointer;\n  \n  width: auto;\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: center;\n  align-items: center;\n\n  padding: 0 0.35em;\n\n  color: #d2d2d2;\n  line-height: 100%;\n  font-style: normal;\n\n  /* Resume pointer-events on children components */\n  pointer-events: initial;\n\n  transition: color .2s, opacity .2s;\n}\n\n.vue__time-picker .controls > *:hover {\n  color: #797979;\n}\n\n.vue__time-picker .controls > *:focus,\n.vue__time-picker .controls > *:active {\n  outline: 0;\n}\n\n.vue__time-picker .controls .char {\n  font-size: 1.1em;\n  line-height: 100%;\n\n  /* Vertical align fixes for webkit browsers only */\n  -webkit-margin-before: -0.15em;\n}\n\n.vue__time-picker .custom-icon {\n  z-index: 2;\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  width: 1.8em;\n\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: center;\n  align-items: center;\n\n  /* pass down mouse events to the <input> underneath */\n  pointer-events: none;\n}\n\n.vue__time-picker .custom-icon img,\n.vue__time-picker .custom-icon svg,\n.vue__time-picker .controls img,\n.vue__time-picker .controls svg {\n  display: inline-block;\n  vertical-align: middle;\n  margin: 0;\n  border: 0;\n  outline: 0;\n  max-width: 1em;\n  height: auto;\n}\n\n.vue__time-picker .time-picker-overlay {\n  z-index: 4;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.vue__time-picker .dropdown,\n.vue__time-picker-dropdown {\n  position: absolute;\n  z-index: 5;\n  top: calc(2.2em + 2px);\n  left: 0;\n  background: #fff;\n  box-shadow: 0 1px 6px rgba(0,0,0,0.15);\n  width: 10em;\n  height: 10em;\n  font-weight: normal;\n}\n\n/* Dropdown class when \"append-to-body\" is on */\n.vue__time-picker-dropdown {\n  position: fixed;\n  z-index: 100;\n}\n\n.vue__time-picker .dropdown.drop-up,\n.vue__time-picker-dropdown.drop-up {\n  top: auto;\n  bottom: calc(2.2em + 1px);\n}\n\n.vue__time-picker .dropdown .select-list,\n.vue__time-picker-dropdown .select-list {\n  width: 10em;\n  height: 10em;\n  overflow: hidden;\n  display: flex;\n  flex-flow: row nowrap;\n  align-items: stretch;\n  justify-content: space-between;\n}\n\n.vue__time-picker .dropdown .select-list:focus,\n.vue__time-picker .dropdown .select-list:active,\n.vue__time-picker-dropdown .select-list:focus,\n.vue__time-picker-dropdown .select-list:active {\n  outline: 0;\n}\n\n.vue__time-picker .dropdown ul,\n.vue__time-picker-dropdown ul {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  outline: 0;\n\n  flex: 1 1 0.00001px;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.vue__time-picker .dropdown ul.minutes,\n.vue__time-picker .dropdown ul.seconds,\n.vue__time-picker .dropdown ul.apms,\n.vue__time-picker-dropdown ul.minutes,\n.vue__time-picker-dropdown ul.seconds,\n.vue__time-picker-dropdown ul.apms {\n  border-left: 1px solid #fff;\n}\n\n.vue__time-picker .dropdown ul li,\n.vue__time-picker-dropdown ul li {\n  list-style: none;\n  text-align: center;\n  padding: 0.3em 0;\n  color: #161616;\n}\n\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):focus,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):focus  {\n  background: rgba(0,0,0,.08);\n  color: #161616;\n  cursor: pointer;\n}\n\n.vue__time-picker .dropdown ul li:not([disabled]).active,\n.vue__time-picker .dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker .dropdown ul li:not([disabled]).active:focus,\n.vue__time-picker-dropdown ul li:not([disabled]).active,\n.vue__time-picker-dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker-dropdown ul li:not([disabled]).active:focus {\n  background: #41B883;\n  color: #fff;\n}\n\n.vue__time-picker .dropdown ul li[disabled],\n.vue__time-picker .dropdown ul li[disabled]:hover,\n.vue__time-picker-dropdown ul li[disabled],\n.vue__time-picker-dropdown ul li[disabled]:hover {\n  background: transparent;\n  opacity: 0.3;\n  cursor: not-allowed;\n}\n\n.vue__time-picker .dropdown .hint,\n.vue__time-picker-dropdown .hint {\n  color: #a5a5a5;\n  cursor: default;\n  font-size: 0.8em;\n}\n</style>\n"]}]}